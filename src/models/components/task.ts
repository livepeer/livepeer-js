/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { Asset, Asset$ } from "./asset";
import { EncryptionOutput, EncryptionOutput$ } from "./encryptionoutput";
import { ExportTaskParams, ExportTaskParams$ } from "./exporttaskparams";
import { InputCreatorId, InputCreatorId$ } from "./inputcreatorid";
import { IpfsExportParams, IpfsExportParams$ } from "./ipfsexportparams";
import { TranscodeProfile, TranscodeProfile$ } from "./transcodeprofile";
import * as z from "zod";

/**
 * Type of the task
 */
export enum TaskType {
    Upload = "upload",
    Export = "export",
    ExportData = "export-data",
    TranscodeFile = "transcode-file",
    Clip = "clip",
}

/**
 * Parameters for the upload task
 */
export type Upload = {
    /**
     * URL of the asset to "upload"
     */
    url?: string | undefined;
    encryption?: EncryptionOutput | undefined;
    /**
     * Decides if the output video should include C2PA signature
     */
    c2pa?: boolean | undefined;
    profiles?: Array<TranscodeProfile> | undefined;
    /**
     * How many seconds the duration of each output segment should be
     */
    targetSegmentSizeSecs?: number | undefined;
};

/**
 * File content to store into IPFS
 */
export type Content = {};

/**
 * Parameters for the export-data task
 */
export type TaskExportData = {
    /**
     * File content to store into IPFS
     */
    content: Content;
    ipfs?: IpfsExportParams | undefined;
    /**
     * Optional type of content
     */
    type?: string | undefined;
    /**
     * Optional ID of the content
     */
    id?: string | undefined;
};

/**
 * Input video file to transcode
 */
export type TaskInput = {
    /**
     * URL of a video to transcode, accepts object-store format
     *
     * @remarks
     * "s3+https"
     *
     */
    url?: string | undefined;
};

/**
 * Storage for the output files
 */
export type TaskStorage = {
    /**
     * URL of the output storage, accepts object-store format
     *
     * @remarks
     * "s3+https"
     *
     */
    url?: string | undefined;
};

/**
 * HLS output format
 */
export type TaskHls = {
    /**
     * Path for the HLS output
     */
    path?: string | undefined;
};

/**
 * MP4 output format
 */
export type TaskMp4 = {
    /**
     * Path for the MP4 output
     */
    path?: string | undefined;
};

/**
 * Output formats
 */
export type TaskOutputs = {
    /**
     * HLS output format
     */
    hls?: TaskHls | undefined;
    /**
     * MP4 output format
     */
    mp4?: TaskMp4 | undefined;
};

/**
 * Parameters for the transcode-file task
 */
export type TranscodeFile = {
    /**
     * Input video file to transcode
     */
    input?: TaskInput | undefined;
    /**
     * Storage for the output files
     */
    storage?: TaskStorage | undefined;
    /**
     * Output formats
     */
    outputs?: TaskOutputs | undefined;
    profiles?: Array<TranscodeProfile> | undefined;
    /**
     * How many seconds the duration of each output segment should
     *
     * @remarks
     * be
     *
     */
    targetSegmentSizeSecs?: number | undefined;
    creatorId?: InputCreatorId | undefined;
    /**
     * Decides if the output video should include C2PA signature
     */
    c2pa?: boolean | undefined;
};

/**
 * Strategy to use for clipping the asset. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
 */
export type ClipStrategy = {
    /**
     * The start timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    startTime?: number | undefined;
    /**
     * The end timestamp of the clip in Unix milliseconds. _See the ClipTrigger in the UI Kit for an example of how this is calculated (for HLS, it uses `Program Date-Time` tags, and for WebRTC, it uses the latency from server to client at stream startup)._
     */
    endTime?: number | undefined;
    /**
     * The playback ID of the stream or stream recording to clip. Asset playback IDs are not supported yet.
     */
    playbackId?: string | undefined;
};

/**
 * Force to use a specific strategy in the Catalyst pipeline. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
 */
export enum CatalystPipelineStrategy {
    Catalyst = "catalyst",
    CatalystFfmpeg = "catalyst_ffmpeg",
    BackgroundExternal = "background_external",
    BackgroundMist = "background_mist",
    FallbackExternal = "fallback_external",
    External = "external",
}

export type Clip = {
    /**
     * URL of the asset to "clip"
     */
    url?: string | undefined;
    /**
     * Strategy to use for clipping the asset. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
     */
    clipStrategy?: ClipStrategy | undefined;
    /**
     * Force to use a specific strategy in the Catalyst pipeline. If not specified, the default strategy that Catalyst is configured for will be used. This field only available for admin users, and is only used for E2E testing.
     */
    catalystPipelineStrategy?: CatalystPipelineStrategy | undefined;
    /**
     * ID of the session
     */
    sessionId?: string | undefined;
    /**
     * ID of the input asset or stream
     */
    inputId?: string | undefined;
};

/**
 * Parameters of the task
 */
export type Params = {
    /**
     * Parameters for the upload task
     */
    upload?: Upload | undefined;
    /**
     * Parameters for the export task
     */
    export?: ExportTaskParams | undefined;
    /**
     * Parameters for the export-data task
     */
    exportData?: TaskExportData | undefined;
    /**
     * Parameters for the transcode-file task
     */
    transcodeFile?: TranscodeFile | undefined;
    clip?: Clip | undefined;
};

/**
 * Phase of the task
 */
export enum TaskPhase {
    Pending = "pending",
    Waiting = "waiting",
    Running = "running",
    Failed = "failed",
    Completed = "completed",
    Cancelled = "cancelled",
}

/**
 * Status of the task
 */
export type TaskStatus = {
    /**
     * Phase of the task
     */
    phase: TaskPhase;
    /**
     * Timestamp (in milliseconds) at which task was updated
     */
    updatedAt: number;
    /**
     * Current progress of the task in a 0-1 ratio
     */
    progress?: number | undefined;
    /**
     * Error message if the task failed
     */
    errorMessage?: string | undefined;
    /**
     * Number of retries done on the task
     */
    retries?: number | undefined;
};

/**
 * Output of the upload task
 */
export type TaskUpload = {
    assetSpec?: Asset | undefined;
    additionalProperties: Record<string, any>;
};

export type TaskIpfs = {
    /**
     * IPFS CID of the exported video file
     */
    videoFileCid: string;
    /**
     * URL for the file with the IPFS protocol
     */
    videoFileUrl?: string | undefined;
    /**
     * URL to access file via HTTP through an IPFS gateway
     */
    videoFileGatewayUrl?: string | undefined;
    /**
     * IPFS CID of the default metadata exported for the video
     */
    nftMetadataCid?: string | undefined;
    /**
     * URL for the metadata file with the IPFS protocol
     */
    nftMetadataUrl?: string | undefined;
    /**
     * URL to access metadata file via HTTP through an IPFS
     *
     * @remarks
     * gateway
     *
     */
    nftMetadataGatewayUrl?: string | undefined;
};

/**
 * Output of the export task
 */
export type Export = {
    ipfs?: TaskIpfs | undefined;
};

export type TaskSchemasIpfs = {
    /**
     * IPFS CID of the exported data
     */
    cid: string;
};

/**
 * Output of the export data task
 */
export type ExportData = {
    ipfs?: TaskSchemasIpfs | undefined;
};

/**
 * Output of the task
 */
export type Output = {
    /**
     * Output of the upload task
     */
    upload?: TaskUpload | undefined;
    /**
     * Output of the export task
     */
    export?: Export | undefined;
    /**
     * Output of the export data task
     */
    exportData?: ExportData | undefined;
};

export type Task = {
    /**
     * Task ID
     */
    id?: string | undefined;
    /**
     * Type of the task
     */
    type?: TaskType | undefined;
    /**
     * Timestamp (in milliseconds) at which task was created
     */
    createdAt?: number | undefined;
    /**
     * Timestamp (in milliseconds) at which the task was scheduled for
     *
     * @remarks
     * execution (e.g. after file upload finished).
     *
     */
    scheduledAt?: number | undefined;
    /**
     * ID of the input asset
     */
    inputAssetId?: string | undefined;
    /**
     * ID of the output asset
     */
    outputAssetId?: string | undefined;
    /**
     * ID of the requester hash(IP + SALT + PlaybackId)
     */
    requesterId?: string | undefined;
    /**
     * Parameters of the task
     */
    params?: Params | undefined;
    /**
     * Status of the task
     */
    status?: TaskStatus | undefined;
    /**
     * Output of the task
     */
    output?: Output | undefined;
};

/** @internal */
export const TaskType$: z.ZodNativeEnum<typeof TaskType> = z.nativeEnum(TaskType);

/** @internal */
export namespace Upload$ {
    export const inboundSchema: z.ZodType<Upload, z.ZodTypeDef, unknown> = z
        .object({
            url: z.string().optional(),
            encryption: EncryptionOutput$.inboundSchema.optional(),
            c2pa: z.boolean().optional(),
            profiles: z.array(TranscodeProfile$.inboundSchema).optional(),
            targetSegmentSizeSecs: z.number().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
                ...(v.c2pa === undefined ? null : { c2pa: v.c2pa }),
                ...(v.profiles === undefined ? null : { profiles: v.profiles }),
                ...(v.targetSegmentSizeSecs === undefined
                    ? null
                    : { targetSegmentSizeSecs: v.targetSegmentSizeSecs }),
            };
        });

    export type Outbound = {
        url?: string | undefined;
        encryption?: EncryptionOutput$.Outbound | undefined;
        c2pa?: boolean | undefined;
        profiles?: Array<TranscodeProfile$.Outbound> | undefined;
        targetSegmentSizeSecs?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Upload> = z
        .object({
            url: z.string().optional(),
            encryption: EncryptionOutput$.outboundSchema.optional(),
            c2pa: z.boolean().optional(),
            profiles: z.array(TranscodeProfile$.outboundSchema).optional(),
            targetSegmentSizeSecs: z.number().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
                ...(v.c2pa === undefined ? null : { c2pa: v.c2pa }),
                ...(v.profiles === undefined ? null : { profiles: v.profiles }),
                ...(v.targetSegmentSizeSecs === undefined
                    ? null
                    : { targetSegmentSizeSecs: v.targetSegmentSizeSecs }),
            };
        });
}

/** @internal */
export namespace Content$ {
    export const inboundSchema: z.ZodType<Content, z.ZodTypeDef, unknown> = z.object({});

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Content> = z.object({});
}

/** @internal */
export namespace TaskExportData$ {
    export const inboundSchema: z.ZodType<TaskExportData, z.ZodTypeDef, unknown> = z
        .object({
            content: z.lazy(() => Content$.inboundSchema),
            ipfs: IpfsExportParams$.inboundSchema.optional(),
            type: z.string().optional(),
            id: z.string().optional(),
        })
        .transform((v) => {
            return {
                content: v.content,
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.id === undefined ? null : { id: v.id }),
            };
        });

    export type Outbound = {
        content: Content$.Outbound;
        ipfs?: IpfsExportParams$.Outbound | undefined;
        type?: string | undefined;
        id?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskExportData> = z
        .object({
            content: z.lazy(() => Content$.outboundSchema),
            ipfs: IpfsExportParams$.outboundSchema.optional(),
            type: z.string().optional(),
            id: z.string().optional(),
        })
        .transform((v) => {
            return {
                content: v.content,
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.id === undefined ? null : { id: v.id }),
            };
        });
}

/** @internal */
export namespace TaskInput$ {
    export const inboundSchema: z.ZodType<TaskInput, z.ZodTypeDef, unknown> = z
        .object({
            url: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
            };
        });

    export type Outbound = {
        url?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskInput> = z
        .object({
            url: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
            };
        });
}

/** @internal */
export namespace TaskStorage$ {
    export const inboundSchema: z.ZodType<TaskStorage, z.ZodTypeDef, unknown> = z
        .object({
            url: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
            };
        });

    export type Outbound = {
        url?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskStorage> = z
        .object({
            url: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
            };
        });
}

/** @internal */
export namespace TaskHls$ {
    export const inboundSchema: z.ZodType<TaskHls, z.ZodTypeDef, unknown> = z
        .object({
            path: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.path === undefined ? null : { path: v.path }),
            };
        });

    export type Outbound = {
        path?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskHls> = z
        .object({
            path: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.path === undefined ? null : { path: v.path }),
            };
        });
}

/** @internal */
export namespace TaskMp4$ {
    export const inboundSchema: z.ZodType<TaskMp4, z.ZodTypeDef, unknown> = z
        .object({
            path: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.path === undefined ? null : { path: v.path }),
            };
        });

    export type Outbound = {
        path?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskMp4> = z
        .object({
            path: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.path === undefined ? null : { path: v.path }),
            };
        });
}

/** @internal */
export namespace TaskOutputs$ {
    export const inboundSchema: z.ZodType<TaskOutputs, z.ZodTypeDef, unknown> = z
        .object({
            hls: z.lazy(() => TaskHls$.inboundSchema).optional(),
            mp4: z.lazy(() => TaskMp4$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.hls === undefined ? null : { hls: v.hls }),
                ...(v.mp4 === undefined ? null : { mp4: v.mp4 }),
            };
        });

    export type Outbound = {
        hls?: TaskHls$.Outbound | undefined;
        mp4?: TaskMp4$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskOutputs> = z
        .object({
            hls: z.lazy(() => TaskHls$.outboundSchema).optional(),
            mp4: z.lazy(() => TaskMp4$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.hls === undefined ? null : { hls: v.hls }),
                ...(v.mp4 === undefined ? null : { mp4: v.mp4 }),
            };
        });
}

/** @internal */
export namespace TranscodeFile$ {
    export const inboundSchema: z.ZodType<TranscodeFile, z.ZodTypeDef, unknown> = z
        .object({
            input: z.lazy(() => TaskInput$.inboundSchema).optional(),
            storage: z.lazy(() => TaskStorage$.inboundSchema).optional(),
            outputs: z.lazy(() => TaskOutputs$.inboundSchema).optional(),
            profiles: z.array(TranscodeProfile$.inboundSchema).optional(),
            targetSegmentSizeSecs: z.number().optional(),
            creatorId: InputCreatorId$.inboundSchema.optional(),
            c2pa: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.input === undefined ? null : { input: v.input }),
                ...(v.storage === undefined ? null : { storage: v.storage }),
                ...(v.outputs === undefined ? null : { outputs: v.outputs }),
                ...(v.profiles === undefined ? null : { profiles: v.profiles }),
                ...(v.targetSegmentSizeSecs === undefined
                    ? null
                    : { targetSegmentSizeSecs: v.targetSegmentSizeSecs }),
                ...(v.creatorId === undefined ? null : { creatorId: v.creatorId }),
                ...(v.c2pa === undefined ? null : { c2pa: v.c2pa }),
            };
        });

    export type Outbound = {
        input?: TaskInput$.Outbound | undefined;
        storage?: TaskStorage$.Outbound | undefined;
        outputs?: TaskOutputs$.Outbound | undefined;
        profiles?: Array<TranscodeProfile$.Outbound> | undefined;
        targetSegmentSizeSecs?: number | undefined;
        creatorId?: InputCreatorId$.Outbound | undefined;
        c2pa?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TranscodeFile> = z
        .object({
            input: z.lazy(() => TaskInput$.outboundSchema).optional(),
            storage: z.lazy(() => TaskStorage$.outboundSchema).optional(),
            outputs: z.lazy(() => TaskOutputs$.outboundSchema).optional(),
            profiles: z.array(TranscodeProfile$.outboundSchema).optional(),
            targetSegmentSizeSecs: z.number().optional(),
            creatorId: InputCreatorId$.outboundSchema.optional(),
            c2pa: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.input === undefined ? null : { input: v.input }),
                ...(v.storage === undefined ? null : { storage: v.storage }),
                ...(v.outputs === undefined ? null : { outputs: v.outputs }),
                ...(v.profiles === undefined ? null : { profiles: v.profiles }),
                ...(v.targetSegmentSizeSecs === undefined
                    ? null
                    : { targetSegmentSizeSecs: v.targetSegmentSizeSecs }),
                ...(v.creatorId === undefined ? null : { creatorId: v.creatorId }),
                ...(v.c2pa === undefined ? null : { c2pa: v.c2pa }),
            };
        });
}

/** @internal */
export namespace ClipStrategy$ {
    export const inboundSchema: z.ZodType<ClipStrategy, z.ZodTypeDef, unknown> = z
        .object({
            startTime: z.number().optional(),
            endTime: z.number().optional(),
            playbackId: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.startTime === undefined ? null : { startTime: v.startTime }),
                ...(v.endTime === undefined ? null : { endTime: v.endTime }),
                ...(v.playbackId === undefined ? null : { playbackId: v.playbackId }),
            };
        });

    export type Outbound = {
        startTime?: number | undefined;
        endTime?: number | undefined;
        playbackId?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ClipStrategy> = z
        .object({
            startTime: z.number().optional(),
            endTime: z.number().optional(),
            playbackId: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.startTime === undefined ? null : { startTime: v.startTime }),
                ...(v.endTime === undefined ? null : { endTime: v.endTime }),
                ...(v.playbackId === undefined ? null : { playbackId: v.playbackId }),
            };
        });
}

/** @internal */
export const CatalystPipelineStrategy$: z.ZodNativeEnum<typeof CatalystPipelineStrategy> =
    z.nativeEnum(CatalystPipelineStrategy);

/** @internal */
export namespace Clip$ {
    export const inboundSchema: z.ZodType<Clip, z.ZodTypeDef, unknown> = z
        .object({
            url: z.string().optional(),
            clipStrategy: z.lazy(() => ClipStrategy$.inboundSchema).optional(),
            catalystPipelineStrategy: CatalystPipelineStrategy$.optional(),
            sessionId: z.string().optional(),
            inputId: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
                ...(v.clipStrategy === undefined ? null : { clipStrategy: v.clipStrategy }),
                ...(v.catalystPipelineStrategy === undefined
                    ? null
                    : { catalystPipelineStrategy: v.catalystPipelineStrategy }),
                ...(v.sessionId === undefined ? null : { sessionId: v.sessionId }),
                ...(v.inputId === undefined ? null : { inputId: v.inputId }),
            };
        });

    export type Outbound = {
        url?: string | undefined;
        clipStrategy?: ClipStrategy$.Outbound | undefined;
        catalystPipelineStrategy?: CatalystPipelineStrategy | undefined;
        sessionId?: string | undefined;
        inputId?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Clip> = z
        .object({
            url: z.string().optional(),
            clipStrategy: z.lazy(() => ClipStrategy$.outboundSchema).optional(),
            catalystPipelineStrategy: CatalystPipelineStrategy$.optional(),
            sessionId: z.string().optional(),
            inputId: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.url === undefined ? null : { url: v.url }),
                ...(v.clipStrategy === undefined ? null : { clipStrategy: v.clipStrategy }),
                ...(v.catalystPipelineStrategy === undefined
                    ? null
                    : { catalystPipelineStrategy: v.catalystPipelineStrategy }),
                ...(v.sessionId === undefined ? null : { sessionId: v.sessionId }),
                ...(v.inputId === undefined ? null : { inputId: v.inputId }),
            };
        });
}

/** @internal */
export namespace Params$ {
    export const inboundSchema: z.ZodType<Params, z.ZodTypeDef, unknown> = z
        .object({
            upload: z.lazy(() => Upload$.inboundSchema).optional(),
            export: ExportTaskParams$.inboundSchema.optional(),
            exportData: z.lazy(() => TaskExportData$.inboundSchema).optional(),
            "transcode-file": z.lazy(() => TranscodeFile$.inboundSchema).optional(),
            clip: z.lazy(() => Clip$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.upload === undefined ? null : { upload: v.upload }),
                ...(v.export === undefined ? null : { export: v.export }),
                ...(v.exportData === undefined ? null : { exportData: v.exportData }),
                ...(v["transcode-file"] === undefined
                    ? null
                    : { transcodeFile: v["transcode-file"] }),
                ...(v.clip === undefined ? null : { clip: v.clip }),
            };
        });

    export type Outbound = {
        upload?: Upload$.Outbound | undefined;
        export?: ExportTaskParams$.Outbound | undefined;
        exportData?: TaskExportData$.Outbound | undefined;
        "transcode-file"?: TranscodeFile$.Outbound | undefined;
        clip?: Clip$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Params> = z
        .object({
            upload: z.lazy(() => Upload$.outboundSchema).optional(),
            export: ExportTaskParams$.outboundSchema.optional(),
            exportData: z.lazy(() => TaskExportData$.outboundSchema).optional(),
            transcodeFile: z.lazy(() => TranscodeFile$.outboundSchema).optional(),
            clip: z.lazy(() => Clip$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.upload === undefined ? null : { upload: v.upload }),
                ...(v.export === undefined ? null : { export: v.export }),
                ...(v.exportData === undefined ? null : { exportData: v.exportData }),
                ...(v.transcodeFile === undefined ? null : { "transcode-file": v.transcodeFile }),
                ...(v.clip === undefined ? null : { clip: v.clip }),
            };
        });
}

/** @internal */
export const TaskPhase$: z.ZodNativeEnum<typeof TaskPhase> = z.nativeEnum(TaskPhase);

/** @internal */
export namespace TaskStatus$ {
    export const inboundSchema: z.ZodType<TaskStatus, z.ZodTypeDef, unknown> = z
        .object({
            phase: TaskPhase$,
            updatedAt: z.number(),
            progress: z.number().optional(),
            errorMessage: z.string().optional(),
            retries: z.number().optional(),
        })
        .transform((v) => {
            return {
                phase: v.phase,
                updatedAt: v.updatedAt,
                ...(v.progress === undefined ? null : { progress: v.progress }),
                ...(v.errorMessage === undefined ? null : { errorMessage: v.errorMessage }),
                ...(v.retries === undefined ? null : { retries: v.retries }),
            };
        });

    export type Outbound = {
        phase: TaskPhase;
        updatedAt: number;
        progress?: number | undefined;
        errorMessage?: string | undefined;
        retries?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskStatus> = z
        .object({
            phase: TaskPhase$,
            updatedAt: z.number(),
            progress: z.number().optional(),
            errorMessage: z.string().optional(),
            retries: z.number().optional(),
        })
        .transform((v) => {
            return {
                phase: v.phase,
                updatedAt: v.updatedAt,
                ...(v.progress === undefined ? null : { progress: v.progress }),
                ...(v.errorMessage === undefined ? null : { errorMessage: v.errorMessage }),
                ...(v.retries === undefined ? null : { retries: v.retries }),
            };
        });
}

/** @internal */
export namespace TaskUpload$ {
    export const inboundSchema: z.ZodType<TaskUpload, z.ZodTypeDef, unknown> = z
        .object({
            assetSpec: Asset$.inboundSchema.optional(),
        })
        .catchall(z.any())
        .transform((v) => {
            const { assetSpec, ...additionalProperties } = v;

            return {
                ...(v.assetSpec === undefined ? null : { assetSpec: v.assetSpec }),
                additionalProperties,
            };
        });

    export type Outbound = {
        assetSpec?: Asset$.Outbound | undefined;
        [additionalProperties: string]: unknown;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskUpload> = z
        .object({
            assetSpec: Asset$.outboundSchema.optional(),
            additionalProperties: z.record(z.any()),
        })
        .transform((v) => {
            return {
                ...v.additionalProperties,
                ...(v.assetSpec === undefined ? null : { assetSpec: v.assetSpec }),
            };
        });
}

/** @internal */
export namespace TaskIpfs$ {
    export const inboundSchema: z.ZodType<TaskIpfs, z.ZodTypeDef, unknown> = z
        .object({
            videoFileCid: z.string(),
            videoFileUrl: z.string().optional(),
            videoFileGatewayUrl: z.string().optional(),
            nftMetadataCid: z.string().optional(),
            nftMetadataUrl: z.string().optional(),
            nftMetadataGatewayUrl: z.string().optional(),
        })
        .transform((v) => {
            return {
                videoFileCid: v.videoFileCid,
                ...(v.videoFileUrl === undefined ? null : { videoFileUrl: v.videoFileUrl }),
                ...(v.videoFileGatewayUrl === undefined
                    ? null
                    : { videoFileGatewayUrl: v.videoFileGatewayUrl }),
                ...(v.nftMetadataCid === undefined ? null : { nftMetadataCid: v.nftMetadataCid }),
                ...(v.nftMetadataUrl === undefined ? null : { nftMetadataUrl: v.nftMetadataUrl }),
                ...(v.nftMetadataGatewayUrl === undefined
                    ? null
                    : { nftMetadataGatewayUrl: v.nftMetadataGatewayUrl }),
            };
        });

    export type Outbound = {
        videoFileCid: string;
        videoFileUrl?: string | undefined;
        videoFileGatewayUrl?: string | undefined;
        nftMetadataCid?: string | undefined;
        nftMetadataUrl?: string | undefined;
        nftMetadataGatewayUrl?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskIpfs> = z
        .object({
            videoFileCid: z.string(),
            videoFileUrl: z.string().optional(),
            videoFileGatewayUrl: z.string().optional(),
            nftMetadataCid: z.string().optional(),
            nftMetadataUrl: z.string().optional(),
            nftMetadataGatewayUrl: z.string().optional(),
        })
        .transform((v) => {
            return {
                videoFileCid: v.videoFileCid,
                ...(v.videoFileUrl === undefined ? null : { videoFileUrl: v.videoFileUrl }),
                ...(v.videoFileGatewayUrl === undefined
                    ? null
                    : { videoFileGatewayUrl: v.videoFileGatewayUrl }),
                ...(v.nftMetadataCid === undefined ? null : { nftMetadataCid: v.nftMetadataCid }),
                ...(v.nftMetadataUrl === undefined ? null : { nftMetadataUrl: v.nftMetadataUrl }),
                ...(v.nftMetadataGatewayUrl === undefined
                    ? null
                    : { nftMetadataGatewayUrl: v.nftMetadataGatewayUrl }),
            };
        });
}

/** @internal */
export namespace Export$ {
    export const inboundSchema: z.ZodType<Export, z.ZodTypeDef, unknown> = z
        .object({
            ipfs: z.lazy(() => TaskIpfs$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
            };
        });

    export type Outbound = {
        ipfs?: TaskIpfs$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Export> = z
        .object({
            ipfs: z.lazy(() => TaskIpfs$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
            };
        });
}

/** @internal */
export namespace TaskSchemasIpfs$ {
    export const inboundSchema: z.ZodType<TaskSchemasIpfs, z.ZodTypeDef, unknown> = z
        .object({
            cid: z.string(),
        })
        .transform((v) => {
            return {
                cid: v.cid,
            };
        });

    export type Outbound = {
        cid: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TaskSchemasIpfs> = z
        .object({
            cid: z.string(),
        })
        .transform((v) => {
            return {
                cid: v.cid,
            };
        });
}

/** @internal */
export namespace ExportData$ {
    export const inboundSchema: z.ZodType<ExportData, z.ZodTypeDef, unknown> = z
        .object({
            ipfs: z.lazy(() => TaskSchemasIpfs$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
            };
        });

    export type Outbound = {
        ipfs?: TaskSchemasIpfs$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ExportData> = z
        .object({
            ipfs: z.lazy(() => TaskSchemasIpfs$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
            };
        });
}

/** @internal */
export namespace Output$ {
    export const inboundSchema: z.ZodType<Output, z.ZodTypeDef, unknown> = z
        .object({
            upload: z.lazy(() => TaskUpload$.inboundSchema).optional(),
            export: z.lazy(() => Export$.inboundSchema).optional(),
            exportData: z.lazy(() => ExportData$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.upload === undefined ? null : { upload: v.upload }),
                ...(v.export === undefined ? null : { export: v.export }),
                ...(v.exportData === undefined ? null : { exportData: v.exportData }),
            };
        });

    export type Outbound = {
        upload?: TaskUpload$.Outbound | undefined;
        export?: Export$.Outbound | undefined;
        exportData?: ExportData$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Output> = z
        .object({
            upload: z.lazy(() => TaskUpload$.outboundSchema).optional(),
            export: z.lazy(() => Export$.outboundSchema).optional(),
            exportData: z.lazy(() => ExportData$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.upload === undefined ? null : { upload: v.upload }),
                ...(v.export === undefined ? null : { export: v.export }),
                ...(v.exportData === undefined ? null : { exportData: v.exportData }),
            };
        });
}

/** @internal */
export namespace Task$ {
    export const inboundSchema: z.ZodType<Task, z.ZodTypeDef, unknown> = z
        .object({
            id: z.string().optional(),
            type: TaskType$.optional(),
            createdAt: z.number().optional(),
            scheduledAt: z.number().optional(),
            inputAssetId: z.string().optional(),
            outputAssetId: z.string().optional(),
            requesterId: z.string().optional(),
            params: z.lazy(() => Params$.inboundSchema).optional(),
            status: z.lazy(() => TaskStatus$.inboundSchema).optional(),
            output: z.lazy(() => Output$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.scheduledAt === undefined ? null : { scheduledAt: v.scheduledAt }),
                ...(v.inputAssetId === undefined ? null : { inputAssetId: v.inputAssetId }),
                ...(v.outputAssetId === undefined ? null : { outputAssetId: v.outputAssetId }),
                ...(v.requesterId === undefined ? null : { requesterId: v.requesterId }),
                ...(v.params === undefined ? null : { params: v.params }),
                ...(v.status === undefined ? null : { status: v.status }),
                ...(v.output === undefined ? null : { output: v.output }),
            };
        });

    export type Outbound = {
        id?: string | undefined;
        type?: TaskType | undefined;
        createdAt?: number | undefined;
        scheduledAt?: number | undefined;
        inputAssetId?: string | undefined;
        outputAssetId?: string | undefined;
        requesterId?: string | undefined;
        params?: Params$.Outbound | undefined;
        status?: TaskStatus$.Outbound | undefined;
        output?: Output$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Task> = z
        .object({
            id: z.string().optional(),
            type: TaskType$.optional(),
            createdAt: z.number().optional(),
            scheduledAt: z.number().optional(),
            inputAssetId: z.string().optional(),
            outputAssetId: z.string().optional(),
            requesterId: z.string().optional(),
            params: z.lazy(() => Params$.outboundSchema).optional(),
            status: z.lazy(() => TaskStatus$.outboundSchema).optional(),
            output: z.lazy(() => Output$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.scheduledAt === undefined ? null : { scheduledAt: v.scheduledAt }),
                ...(v.inputAssetId === undefined ? null : { inputAssetId: v.inputAssetId }),
                ...(v.outputAssetId === undefined ? null : { outputAssetId: v.outputAssetId }),
                ...(v.requesterId === undefined ? null : { requesterId: v.requesterId }),
                ...(v.params === undefined ? null : { params: v.params }),
                ...(v.status === undefined ? null : { status: v.status }),
                ...(v.output === undefined ? null : { output: v.output }),
            };
        });
}
