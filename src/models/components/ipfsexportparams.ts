/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { NftMetadata, NftMetadata$ } from "./nftmetadata";
import { NftMetadataTemplate, NftMetadataTemplate$ } from "./nftmetadatatemplate";
import { z } from "zod";

export type Pinata2 = {
    /**
     * Will be added to the pinata_api_key header.
     */
    apiKey: string;
    /**
     * Will be added to the pinata_secret_api_key header.
     */
    apiSecret: string;
};

export type Pinata1 = {
    /**
     * Will be added to the Authorization header as a
     *
     * @remarks
     * Bearer token.
     *
     */
    jwt: string;
};

/**
 * Custom credentials for the Piñata service. Must have either
 *
 * @remarks
 * a JWT or an API key and an API secret.
 *
 */
export type Pinata = Pinata1 | Pinata2;

export type IpfsExportParams = {
    /**
     * Name of the NFT metadata template to export. 'player'
     *
     * @remarks
     * will embed the Livepeer Player on the NFT while 'file'
     * will reference only the immutable MP4 files.
     *
     */
    nftMetadataTemplate?: NftMetadataTemplate | undefined;
    /**
     * Additional data to add to the NFT metadata exported to
     *
     * @remarks
     * IPFS. Will be deep merged with the default metadata
     * exported.
     *
     */
    nftMetadata?: NftMetadata | undefined;
    /**
     * Custom credentials for the Piñata service. Must have either
     *
     * @remarks
     * a JWT or an API key and an API secret.
     *
     */
    pinata?: Pinata1 | Pinata2 | undefined;
};

/** @internal */
export namespace Pinata2$ {
    export type Inbound = {
        apiKey: string;
        apiSecret: string;
    };

    export const inboundSchema: z.ZodType<Pinata2, z.ZodTypeDef, Inbound> = z
        .object({
            apiKey: z.string(),
            apiSecret: z.string(),
        })
        .transform((v) => {
            return {
                apiKey: v.apiKey,
                apiSecret: v.apiSecret,
            };
        });

    export type Outbound = {
        apiKey: string;
        apiSecret: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Pinata2> = z
        .object({
            apiKey: z.string(),
            apiSecret: z.string(),
        })
        .transform((v) => {
            return {
                apiKey: v.apiKey,
                apiSecret: v.apiSecret,
            };
        });
}

/** @internal */
export namespace Pinata1$ {
    export type Inbound = {
        jwt: string;
    };

    export const inboundSchema: z.ZodType<Pinata1, z.ZodTypeDef, Inbound> = z
        .object({
            jwt: z.string(),
        })
        .transform((v) => {
            return {
                jwt: v.jwt,
            };
        });

    export type Outbound = {
        jwt: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Pinata1> = z
        .object({
            jwt: z.string(),
        })
        .transform((v) => {
            return {
                jwt: v.jwt,
            };
        });
}

/** @internal */
export namespace Pinata$ {
    export type Inbound = Pinata1$.Inbound | Pinata2$.Inbound;

    export type Outbound = Pinata1$.Outbound | Pinata2$.Outbound;

    export const inboundSchema: z.ZodType<Pinata, z.ZodTypeDef, Inbound> = z.union([
        z.lazy(() => Pinata1$.inboundSchema),
        z.lazy(() => Pinata2$.inboundSchema),
    ]);

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Pinata> = z.union([
        z.lazy(() => Pinata1$.outboundSchema),
        z.lazy(() => Pinata2$.outboundSchema),
    ]);
}

/** @internal */
export namespace IpfsExportParams$ {
    export type Inbound = {
        nftMetadataTemplate?: NftMetadataTemplate | undefined;
        nftMetadata?: NftMetadata$.Inbound | undefined;
        pinata?: Pinata1$.Inbound | Pinata2$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<IpfsExportParams, z.ZodTypeDef, Inbound> = z
        .object({
            nftMetadataTemplate: NftMetadataTemplate$.default(NftMetadataTemplate.File),
            nftMetadata: NftMetadata$.inboundSchema.optional(),
            pinata: z
                .union([z.lazy(() => Pinata1$.inboundSchema), z.lazy(() => Pinata2$.inboundSchema)])
                .optional(),
        })
        .transform((v) => {
            return {
                nftMetadataTemplate: v.nftMetadataTemplate,
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
                ...(v.pinata === undefined ? null : { pinata: v.pinata }),
            };
        });

    export type Outbound = {
        nftMetadataTemplate: NftMetadataTemplate;
        nftMetadata?: NftMetadata$.Outbound | undefined;
        pinata?: Pinata1$.Outbound | Pinata2$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, IpfsExportParams> = z
        .object({
            nftMetadataTemplate: NftMetadataTemplate$.default(NftMetadataTemplate.File),
            nftMetadata: NftMetadata$.outboundSchema.optional(),
            pinata: z
                .union([
                    z.lazy(() => Pinata1$.outboundSchema),
                    z.lazy(() => Pinata2$.outboundSchema),
                ])
                .optional(),
        })
        .transform((v) => {
            return {
                nftMetadataTemplate: v.nftMetadataTemplate,
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
                ...(v.pinata === undefined ? null : { pinata: v.pinata }),
            };
        });
}
