/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { NftMetadata, NftMetadata$ } from "./nftmetadata";
import { NftMetadataTemplate, NftMetadataTemplate$ } from "./nftmetadatatemplate";
import { z } from "zod";

export type IpfsExportParamsPinata2 = {
    /**
     * Will be added to the pinata_api_key header.
     */
    apiKey: string;
};

export type IpfsExportParamsPinata1 = {};

/**
 * Custom credentials for the Piñata service. Must have either
 *
 * @remarks
 * a JWT or an API key and an API secret.
 *
 */
export type IpfsExportParamsPinata = IpfsExportParamsPinata1 | IpfsExportParamsPinata2;

export type IpfsExportParamsOutput = {
    /**
     * Name of the NFT metadata template to export. 'player'
     *
     * @remarks
     * will embed the Livepeer Player on the NFT while 'file'
     * will reference only the immutable MP4 files.
     *
     */
    nftMetadataTemplate?: NftMetadataTemplate | undefined;
    /**
     * Additional data to add to the NFT metadata exported to
     *
     * @remarks
     * IPFS. Will be deep merged with the default metadata
     * exported.
     *
     */
    nftMetadata?: NftMetadata | undefined;
    /**
     * Custom credentials for the Piñata service. Must have either
     *
     * @remarks
     * a JWT or an API key and an API secret.
     *
     */
    pinata?: IpfsExportParamsPinata1 | IpfsExportParamsPinata2 | undefined;
};

/** @internal */
export namespace IpfsExportParamsPinata2$ {
    export type Inbound = {
        apiKey: string;
    };

    export const inboundSchema: z.ZodType<IpfsExportParamsPinata2, z.ZodTypeDef, Inbound> = z
        .object({
            apiKey: z.string(),
        })
        .transform((v) => {
            return {
                apiKey: v.apiKey,
            };
        });

    export type Outbound = {
        apiKey: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, IpfsExportParamsPinata2> = z
        .object({
            apiKey: z.string(),
        })
        .transform((v) => {
            return {
                apiKey: v.apiKey,
            };
        });
}

/** @internal */
export namespace IpfsExportParamsPinata1$ {
    export type Inbound = {};

    export const inboundSchema: z.ZodType<IpfsExportParamsPinata1, z.ZodTypeDef, Inbound> =
        z.object({});

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, IpfsExportParamsPinata1> =
        z.object({});
}

/** @internal */
export namespace IpfsExportParamsPinata$ {
    export type Inbound = IpfsExportParamsPinata1$.Inbound | IpfsExportParamsPinata2$.Inbound;

    export type Outbound = IpfsExportParamsPinata1$.Outbound | IpfsExportParamsPinata2$.Outbound;

    export const inboundSchema: z.ZodType<IpfsExportParamsPinata, z.ZodTypeDef, Inbound> = z.union([
        z.lazy(() => IpfsExportParamsPinata1$.inboundSchema),
        z.lazy(() => IpfsExportParamsPinata2$.inboundSchema),
    ]);

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, IpfsExportParamsPinata> =
        z.union([
            z.lazy(() => IpfsExportParamsPinata1$.outboundSchema),
            z.lazy(() => IpfsExportParamsPinata2$.outboundSchema),
        ]);
}

/** @internal */
export namespace IpfsExportParamsOutput$ {
    export type Inbound = {
        nftMetadataTemplate?: NftMetadataTemplate | undefined;
        nftMetadata?: NftMetadata$.Inbound | undefined;
        pinata?: IpfsExportParamsPinata1$.Inbound | IpfsExportParamsPinata2$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<IpfsExportParamsOutput, z.ZodTypeDef, Inbound> = z
        .object({
            nftMetadataTemplate: NftMetadataTemplate$.default(NftMetadataTemplate.File),
            nftMetadata: NftMetadata$.inboundSchema.optional(),
            pinata: z
                .union([
                    z.lazy(() => IpfsExportParamsPinata1$.inboundSchema),
                    z.lazy(() => IpfsExportParamsPinata2$.inboundSchema),
                ])
                .optional(),
        })
        .transform((v) => {
            return {
                nftMetadataTemplate: v.nftMetadataTemplate,
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
                ...(v.pinata === undefined ? null : { pinata: v.pinata }),
            };
        });

    export type Outbound = {
        nftMetadataTemplate: NftMetadataTemplate;
        nftMetadata?: NftMetadata$.Outbound | undefined;
        pinata?: IpfsExportParamsPinata1$.Outbound | IpfsExportParamsPinata2$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, IpfsExportParamsOutput> = z
        .object({
            nftMetadataTemplate: NftMetadataTemplate$.default(NftMetadataTemplate.File),
            nftMetadata: NftMetadata$.outboundSchema.optional(),
            pinata: z
                .union([
                    z.lazy(() => IpfsExportParamsPinata1$.outboundSchema),
                    z.lazy(() => IpfsExportParamsPinata2$.outboundSchema),
                ])
                .optional(),
        })
        .transform((v) => {
            return {
                nftMetadataTemplate: v.nftMetadataTemplate,
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
                ...(v.pinata === undefined ? null : { pinata: v.pinata }),
            };
        });
}
