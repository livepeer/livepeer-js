/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import {
  CreatorId,
  CreatorId$inboundSchema,
  CreatorId$Outbound,
  CreatorId$outboundSchema,
} from "./creatorid.js";
import {
  FfmpegProfile,
  FfmpegProfile$inboundSchema,
  FfmpegProfile$Outbound,
  FfmpegProfile$outboundSchema,
} from "./ffmpegprofile.js";
import {
  PlaybackPolicy,
  PlaybackPolicy$inboundSchema,
  PlaybackPolicy$Outbound,
  PlaybackPolicy$outboundSchema,
} from "./playbackpolicy.js";
import {
  TargetOutput,
  TargetOutput$inboundSchema,
  TargetOutput$Outbound,
  TargetOutput$outboundSchema,
} from "./targetoutput.js";
import {
  TranscodeProfile,
  TranscodeProfile$inboundSchema,
  TranscodeProfile$Outbound,
  TranscodeProfile$outboundSchema,
} from "./transcodeprofile.js";

export type Stream3 = string | number;

export type StreamUserTags = string | number | Array<string | number>;

/**
 * 0: not mobile, 1: mobile screen share, 2: mobile camera.
 */
export enum Stream1 {
  Zero = 0,
  One = 1,
  Two = 2,
}

/**
 * Indicates whether the stream will be pulled from a mobile source.
 */
export type StreamIsMobile = Stream1 | boolean;

/**
 * Approximate location of the pull source. The location is used to
 *
 * @remarks
 * determine the closest Livepeer region to pull the stream from.
 */
export type StreamLocation = {
  /**
   * Latitude of the pull source in degrees. North is positive,
   *
   * @remarks
   * south is negative.
   */
  lat: number;
  /**
   * Longitude of the pull source in degrees. East is positive,
   *
   * @remarks
   * west is negative.
   */
  lon: number;
};

/**
 * Configuration for a stream that should be actively pulled from an
 *
 * @remarks
 * external source, rather than pushed to Livepeer. If specified, the
 * stream will not have a streamKey.
 */
export type StreamPull = {
  /**
   * URL from which to pull from.
   */
  source: string;
  /**
   * Headers to be sent with the request to the pull source.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * Indicates whether the stream will be pulled from a mobile source.
   */
  isMobile?: Stream1 | boolean | undefined;
  /**
   * Approximate location of the pull source. The location is used to
   *
   * @remarks
   * determine the closest Livepeer region to pull the stream from.
   */
  location?: StreamLocation | undefined;
};

/**
 * Configuration for recording the stream. This can only be set if
 *
 * @remarks
 * `record` is true.
 */
export type StreamRecordingSpec = {
  /**
   * Profiles to process the recording of this stream into. If not
   *
   * @remarks
   * specified, default profiles will be derived based on the stream
   * input. Keep in mind that the source rendition is always kept.
   */
  profiles?: Array<TranscodeProfile> | undefined;
};

export type StreamMultistream = {
  /**
   * References to targets where this stream will be simultaneously
   *
   * @remarks
   * streamed to
   */
  targets?: Array<TargetOutput> | undefined;
};

export type Renditions = {};

export type Stream = {
  id?: string | undefined;
  name: string;
  /**
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  kind?: string | undefined;
  creatorId?: CreatorId | undefined;
  /**
   * User input tags associated with the stream
   */
  userTags?:
    | { [k: string]: string | number | Array<string | number> }
    | undefined;
  lastSeen?: number | undefined;
  sourceSegments?: number | undefined;
  transcodedSegments?: number | undefined;
  /**
   * Duration of all the source segments, sec
   */
  sourceSegmentsDuration?: number | undefined;
  /**
   * Duration of all the transcoded segments, sec
   */
  transcodedSegmentsDuration?: number | undefined;
  sourceBytes?: number | undefined;
  transcodedBytes?: number | undefined;
  /**
   * Rate at which sourceBytes increases (bytes/second)
   */
  ingestRate?: number | undefined;
  /**
   * Rate at which transcodedBytes increases (bytes/second)
   */
  outgoingRate?: number | undefined;
  /**
   * If currently active
   */
  isActive?: boolean | undefined;
  /**
   * Indicates whether the stream is healthy or not.
   */
  isHealthy?: boolean | null | undefined;
  /**
   * A string array of human-readable errors describing issues affecting the stream, if any.
   */
  issues?: Array<string> | null | undefined;
  /**
   * Name of the token used to create this object
   */
  createdByTokenName?: string | undefined;
  /**
   * Timestamp (in milliseconds) at which stream object was created
   */
  createdAt?: number | undefined;
  /**
   * Points to parent stream object
   */
  parentId?: string | undefined;
  /**
   * Used to form RTMP ingest URL
   */
  streamKey?: string | undefined;
  /**
   * Configuration for a stream that should be actively pulled from an
   *
   * @remarks
   * external source, rather than pushed to Livepeer. If specified, the
   * stream will not have a streamKey.
   */
  pull?: StreamPull | undefined;
  /**
   * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
   */
  playbackId?: string | undefined;
  /**
   * Whether the playback policy for an asset or stream is public or signed
   */
  playbackPolicy?: PlaybackPolicy | null | undefined;
  /**
   * Profiles to transcode the stream into. If not specified, a default
   *
   * @remarks
   * set of profiles will be used with 240p, 360p, 480p and 720p
   * resolutions. Keep in mind that the source rendition is always kept.
   */
  profiles?: Array<FfmpegProfile> | undefined;
  /**
   * The ID of the project
   */
  projectId?: string | undefined;
  /**
   * Should this stream be recorded? Uses default settings. For more
   *
   * @remarks
   * customization, create and configure an object store.
   */
  record?: boolean | undefined;
  /**
   * Configuration for recording the stream. This can only be set if
   *
   * @remarks
   * `record` is true.
   */
  recordingSpec?: StreamRecordingSpec | undefined;
  multistream?: StreamMultistream | undefined;
  /**
   * If currently suspended
   */
  suspended?: boolean | undefined;
  /**
   * Timestamp (in milliseconds) when the stream was last terminated
   */
  lastTerminatedAt?: number | null | undefined;
  /**
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  userId?: string | undefined;
  renditions?: Renditions | undefined;
};

/** @internal */
export const Stream3$inboundSchema: z.ZodType<Stream3, z.ZodTypeDef, unknown> =
  z.union([z.string(), z.number()]);

/** @internal */
export type Stream3$Outbound = string | number;

/** @internal */
export const Stream3$outboundSchema: z.ZodType<
  Stream3$Outbound,
  z.ZodTypeDef,
  Stream3
> = z.union([z.string(), z.number()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Stream3$ {
  /** @deprecated use `Stream3$inboundSchema` instead. */
  export const inboundSchema = Stream3$inboundSchema;
  /** @deprecated use `Stream3$outboundSchema` instead. */
  export const outboundSchema = Stream3$outboundSchema;
  /** @deprecated use `Stream3$Outbound` instead. */
  export type Outbound = Stream3$Outbound;
}

/** @internal */
export const StreamUserTags$inboundSchema: z.ZodType<
  StreamUserTags,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.array(z.union([z.string(), z.number()])),
]);

/** @internal */
export type StreamUserTags$Outbound = string | number | Array<string | number>;

/** @internal */
export const StreamUserTags$outboundSchema: z.ZodType<
  StreamUserTags$Outbound,
  z.ZodTypeDef,
  StreamUserTags
> = z.union([
  z.string(),
  z.number(),
  z.array(z.union([z.string(), z.number()])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamUserTags$ {
  /** @deprecated use `StreamUserTags$inboundSchema` instead. */
  export const inboundSchema = StreamUserTags$inboundSchema;
  /** @deprecated use `StreamUserTags$outboundSchema` instead. */
  export const outboundSchema = StreamUserTags$outboundSchema;
  /** @deprecated use `StreamUserTags$Outbound` instead. */
  export type Outbound = StreamUserTags$Outbound;
}

/** @internal */
export const Stream1$inboundSchema: z.ZodNativeEnum<typeof Stream1> = z
  .nativeEnum(Stream1);

/** @internal */
export const Stream1$outboundSchema: z.ZodNativeEnum<typeof Stream1> =
  Stream1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Stream1$ {
  /** @deprecated use `Stream1$inboundSchema` instead. */
  export const inboundSchema = Stream1$inboundSchema;
  /** @deprecated use `Stream1$outboundSchema` instead. */
  export const outboundSchema = Stream1$outboundSchema;
}

/** @internal */
export const StreamIsMobile$inboundSchema: z.ZodType<
  StreamIsMobile,
  z.ZodTypeDef,
  unknown
> = z.union([Stream1$inboundSchema, z.boolean()]);

/** @internal */
export type StreamIsMobile$Outbound = number | boolean;

/** @internal */
export const StreamIsMobile$outboundSchema: z.ZodType<
  StreamIsMobile$Outbound,
  z.ZodTypeDef,
  StreamIsMobile
> = z.union([Stream1$outboundSchema, z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamIsMobile$ {
  /** @deprecated use `StreamIsMobile$inboundSchema` instead. */
  export const inboundSchema = StreamIsMobile$inboundSchema;
  /** @deprecated use `StreamIsMobile$outboundSchema` instead. */
  export const outboundSchema = StreamIsMobile$outboundSchema;
  /** @deprecated use `StreamIsMobile$Outbound` instead. */
  export type Outbound = StreamIsMobile$Outbound;
}

/** @internal */
export const StreamLocation$inboundSchema: z.ZodType<
  StreamLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  lat: z.number(),
  lon: z.number(),
});

/** @internal */
export type StreamLocation$Outbound = {
  lat: number;
  lon: number;
};

/** @internal */
export const StreamLocation$outboundSchema: z.ZodType<
  StreamLocation$Outbound,
  z.ZodTypeDef,
  StreamLocation
> = z.object({
  lat: z.number(),
  lon: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamLocation$ {
  /** @deprecated use `StreamLocation$inboundSchema` instead. */
  export const inboundSchema = StreamLocation$inboundSchema;
  /** @deprecated use `StreamLocation$outboundSchema` instead. */
  export const outboundSchema = StreamLocation$outboundSchema;
  /** @deprecated use `StreamLocation$Outbound` instead. */
  export type Outbound = StreamLocation$Outbound;
}

/** @internal */
export const StreamPull$inboundSchema: z.ZodType<
  StreamPull,
  z.ZodTypeDef,
  unknown
> = z.object({
  source: z.string(),
  headers: z.record(z.string()).optional(),
  isMobile: z.union([Stream1$inboundSchema, z.boolean()]).optional(),
  location: z.lazy(() => StreamLocation$inboundSchema).optional(),
});

/** @internal */
export type StreamPull$Outbound = {
  source: string;
  headers?: { [k: string]: string } | undefined;
  isMobile?: number | boolean | undefined;
  location?: StreamLocation$Outbound | undefined;
};

/** @internal */
export const StreamPull$outboundSchema: z.ZodType<
  StreamPull$Outbound,
  z.ZodTypeDef,
  StreamPull
> = z.object({
  source: z.string(),
  headers: z.record(z.string()).optional(),
  isMobile: z.union([Stream1$outboundSchema, z.boolean()]).optional(),
  location: z.lazy(() => StreamLocation$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamPull$ {
  /** @deprecated use `StreamPull$inboundSchema` instead. */
  export const inboundSchema = StreamPull$inboundSchema;
  /** @deprecated use `StreamPull$outboundSchema` instead. */
  export const outboundSchema = StreamPull$outboundSchema;
  /** @deprecated use `StreamPull$Outbound` instead. */
  export type Outbound = StreamPull$Outbound;
}

/** @internal */
export const StreamRecordingSpec$inboundSchema: z.ZodType<
  StreamRecordingSpec,
  z.ZodTypeDef,
  unknown
> = z.object({
  profiles: z.array(TranscodeProfile$inboundSchema).optional(),
});

/** @internal */
export type StreamRecordingSpec$Outbound = {
  profiles?: Array<TranscodeProfile$Outbound> | undefined;
};

/** @internal */
export const StreamRecordingSpec$outboundSchema: z.ZodType<
  StreamRecordingSpec$Outbound,
  z.ZodTypeDef,
  StreamRecordingSpec
> = z.object({
  profiles: z.array(TranscodeProfile$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRecordingSpec$ {
  /** @deprecated use `StreamRecordingSpec$inboundSchema` instead. */
  export const inboundSchema = StreamRecordingSpec$inboundSchema;
  /** @deprecated use `StreamRecordingSpec$outboundSchema` instead. */
  export const outboundSchema = StreamRecordingSpec$outboundSchema;
  /** @deprecated use `StreamRecordingSpec$Outbound` instead. */
  export type Outbound = StreamRecordingSpec$Outbound;
}

/** @internal */
export const StreamMultistream$inboundSchema: z.ZodType<
  StreamMultistream,
  z.ZodTypeDef,
  unknown
> = z.object({
  targets: z.array(TargetOutput$inboundSchema).optional(),
});

/** @internal */
export type StreamMultistream$Outbound = {
  targets?: Array<TargetOutput$Outbound> | undefined;
};

/** @internal */
export const StreamMultistream$outboundSchema: z.ZodType<
  StreamMultistream$Outbound,
  z.ZodTypeDef,
  StreamMultistream
> = z.object({
  targets: z.array(TargetOutput$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamMultistream$ {
  /** @deprecated use `StreamMultistream$inboundSchema` instead. */
  export const inboundSchema = StreamMultistream$inboundSchema;
  /** @deprecated use `StreamMultistream$outboundSchema` instead. */
  export const outboundSchema = StreamMultistream$outboundSchema;
  /** @deprecated use `StreamMultistream$Outbound` instead. */
  export type Outbound = StreamMultistream$Outbound;
}

/** @internal */
export const Renditions$inboundSchema: z.ZodType<
  Renditions,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type Renditions$Outbound = {};

/** @internal */
export const Renditions$outboundSchema: z.ZodType<
  Renditions$Outbound,
  z.ZodTypeDef,
  Renditions
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Renditions$ {
  /** @deprecated use `Renditions$inboundSchema` instead. */
  export const inboundSchema = Renditions$inboundSchema;
  /** @deprecated use `Renditions$outboundSchema` instead. */
  export const outboundSchema = Renditions$outboundSchema;
  /** @deprecated use `Renditions$Outbound` instead. */
  export type Outbound = Renditions$Outbound;
}

/** @internal */
export const Stream$inboundSchema: z.ZodType<Stream, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string().optional(),
    name: z.string(),
    kind: z.string().optional(),
    creatorId: CreatorId$inboundSchema.optional(),
    userTags: z.record(
      z.union([
        z.string(),
        z.number(),
        z.array(z.union([z.string(), z.number()])),
      ]),
    ).optional(),
    lastSeen: z.number().optional(),
    sourceSegments: z.number().optional(),
    transcodedSegments: z.number().optional(),
    sourceSegmentsDuration: z.number().optional(),
    transcodedSegmentsDuration: z.number().optional(),
    sourceBytes: z.number().optional(),
    transcodedBytes: z.number().optional(),
    ingestRate: z.number().optional(),
    outgoingRate: z.number().optional(),
    isActive: z.boolean().optional(),
    isHealthy: z.nullable(z.boolean()).optional(),
    issues: z.nullable(z.array(z.string())).optional(),
    createdByTokenName: z.string().optional(),
    createdAt: z.number().optional(),
    parentId: z.string().optional(),
    streamKey: z.string().optional(),
    pull: z.lazy(() => StreamPull$inboundSchema).optional(),
    playbackId: z.string().optional(),
    playbackPolicy: z.nullable(PlaybackPolicy$inboundSchema).optional(),
    profiles: z.array(FfmpegProfile$inboundSchema).optional(),
    projectId: z.string().optional(),
    record: z.boolean().optional(),
    recordingSpec: z.lazy(() => StreamRecordingSpec$inboundSchema).optional(),
    multistream: z.lazy(() => StreamMultistream$inboundSchema).optional(),
    suspended: z.boolean().optional(),
    lastTerminatedAt: z.nullable(z.number()).optional(),
    userId: z.string().optional(),
    renditions: z.lazy(() => Renditions$inboundSchema).optional(),
  });

/** @internal */
export type Stream$Outbound = {
  id?: string | undefined;
  name: string;
  kind?: string | undefined;
  creatorId?: CreatorId$Outbound | undefined;
  userTags?:
    | { [k: string]: string | number | Array<string | number> }
    | undefined;
  lastSeen?: number | undefined;
  sourceSegments?: number | undefined;
  transcodedSegments?: number | undefined;
  sourceSegmentsDuration?: number | undefined;
  transcodedSegmentsDuration?: number | undefined;
  sourceBytes?: number | undefined;
  transcodedBytes?: number | undefined;
  ingestRate?: number | undefined;
  outgoingRate?: number | undefined;
  isActive?: boolean | undefined;
  isHealthy?: boolean | null | undefined;
  issues?: Array<string> | null | undefined;
  createdByTokenName?: string | undefined;
  createdAt?: number | undefined;
  parentId?: string | undefined;
  streamKey?: string | undefined;
  pull?: StreamPull$Outbound | undefined;
  playbackId?: string | undefined;
  playbackPolicy?: PlaybackPolicy$Outbound | null | undefined;
  profiles?: Array<FfmpegProfile$Outbound> | undefined;
  projectId?: string | undefined;
  record?: boolean | undefined;
  recordingSpec?: StreamRecordingSpec$Outbound | undefined;
  multistream?: StreamMultistream$Outbound | undefined;
  suspended?: boolean | undefined;
  lastTerminatedAt?: number | null | undefined;
  userId?: string | undefined;
  renditions?: Renditions$Outbound | undefined;
};

/** @internal */
export const Stream$outboundSchema: z.ZodType<
  Stream$Outbound,
  z.ZodTypeDef,
  Stream
> = z.object({
  id: z.string().optional(),
  name: z.string(),
  kind: z.string().optional(),
  creatorId: CreatorId$outboundSchema.optional(),
  userTags: z.record(
    z.union([
      z.string(),
      z.number(),
      z.array(z.union([z.string(), z.number()])),
    ]),
  ).optional(),
  lastSeen: z.number().optional(),
  sourceSegments: z.number().optional(),
  transcodedSegments: z.number().optional(),
  sourceSegmentsDuration: z.number().optional(),
  transcodedSegmentsDuration: z.number().optional(),
  sourceBytes: z.number().optional(),
  transcodedBytes: z.number().optional(),
  ingestRate: z.number().optional(),
  outgoingRate: z.number().optional(),
  isActive: z.boolean().optional(),
  isHealthy: z.nullable(z.boolean()).optional(),
  issues: z.nullable(z.array(z.string())).optional(),
  createdByTokenName: z.string().optional(),
  createdAt: z.number().optional(),
  parentId: z.string().optional(),
  streamKey: z.string().optional(),
  pull: z.lazy(() => StreamPull$outboundSchema).optional(),
  playbackId: z.string().optional(),
  playbackPolicy: z.nullable(PlaybackPolicy$outboundSchema).optional(),
  profiles: z.array(FfmpegProfile$outboundSchema).optional(),
  projectId: z.string().optional(),
  record: z.boolean().optional(),
  recordingSpec: z.lazy(() => StreamRecordingSpec$outboundSchema).optional(),
  multistream: z.lazy(() => StreamMultistream$outboundSchema).optional(),
  suspended: z.boolean().optional(),
  lastTerminatedAt: z.nullable(z.number()).optional(),
  userId: z.string().optional(),
  renditions: z.lazy(() => Renditions$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Stream$ {
  /** @deprecated use `Stream$inboundSchema` instead. */
  export const inboundSchema = Stream$inboundSchema;
  /** @deprecated use `Stream$outboundSchema` instead. */
  export const outboundSchema = Stream$outboundSchema;
  /** @deprecated use `Stream$Outbound` instead. */
  export type Outbound = Stream$Outbound;
}
