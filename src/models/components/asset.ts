/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { CreatorId, CreatorId$ } from "./creatorid";
import { Encryption, Encryption$ } from "./encryption";
import { EncryptionOutput, EncryptionOutput$ } from "./encryptionoutput";
import { IpfsFileInfo, IpfsFileInfo$ } from "./ipfsfileinfo";
import { IpfsFileInfoInput, IpfsFileInfoInput$ } from "./ipfsfileinfoinput";
import { PlaybackPolicy, PlaybackPolicy$ } from "./playbackpolicy";
import { StorageStatus, StorageStatus$ } from "./storagestatus";
import { z } from "zod";

/**
 * Type of the asset.
 */
export enum AssetType {
    Video = "video",
    Audio = "audio",
}

export enum AssetSource3Type {
    DirectUpload = "directUpload",
    Clip = "clip",
}

export type Source3 = {
    type: AssetSource3Type;
    encryption?: EncryptionOutput | undefined;
};

export enum AssetSourceType {
    Recording = "recording",
}

export type Two = {
    type: AssetSourceType;
    /**
     * ID of the session from which this asset was created
     */
    sessionId: string;
};

export enum SourceType {
    Url = "url",
}

export type AssetSource1 = {
    type: SourceType;
    /**
     * URL from which the asset was uploaded
     */
    url: string;
    /**
     * Gateway URL from asset if parsed from provided URL on upload.
     */
    gatewayUrl?: string | undefined;
    encryption?: EncryptionOutput | undefined;
};

export type AssetSource = Two | Source3 | AssetSource1;

/**
 * Name of the NFT metadata template to export. 'player'
 *
 * @remarks
 * will embed the Livepeer Player on the NFT while 'file'
 * will reference only the immutable MP4 files.
 *
 */
export enum AssetNftMetadataTemplate {
    File = "file",
    Player = "player",
}

/**
 * Additional data to add to the NFT metadata exported to
 *
 * @remarks
 * IPFS. Will be deep merged with the default metadata
 * exported.
 *
 */
export type AssetNftMetadata = {};

export type AssetSpec = {
    /**
     * Name of the NFT metadata template to export. 'player'
     *
     * @remarks
     * will embed the Livepeer Player on the NFT while 'file'
     * will reference only the immutable MP4 files.
     *
     */
    nftMetadataTemplate?: AssetNftMetadataTemplate | undefined;
    /**
     * Additional data to add to the NFT metadata exported to
     *
     * @remarks
     * IPFS. Will be deep merged with the default metadata
     * exported.
     *
     */
    nftMetadata?: AssetNftMetadata | undefined;
};

export type AssetIpfs = {
    spec?: AssetSpec | undefined;
    /**
     * CID of the file on IPFS
     */
    cid?: string | undefined;
    /**
     * URL with IPFS scheme for the file
     */
    url?: string | undefined;
    /**
     * URL to access file via HTTP through an IPFS gateway
     */
    gatewayUrl?: string | undefined;
    nftMetadata?: IpfsFileInfo | undefined;
    /**
     * Timestamp (in milliseconds) at which IPFS export task was
     *
     * @remarks
     * updated
     *
     */
    updatedAt?: number | undefined;
};

export type AssetStorage = {
    ipfs?: AssetIpfs | undefined;
    status?: StorageStatus | undefined;
};

/**
 * Phase of the asset
 */
export enum AssetPhase {
    Uploading = "uploading",
    Waiting = "waiting",
    Processing = "processing",
    Ready = "ready",
    Failed = "failed",
}

/**
 * Status of the asset
 */
export type AssetStatus = {
    /**
     * Phase of the asset
     */
    phase: AssetPhase;
    /**
     * Timestamp (in milliseconds) at which the asset was last updated
     */
    updatedAt: number;
    /**
     * Current progress of the task creating this asset.
     */
    progress?: number | undefined;
    /**
     * Error message if the asset creation failed.
     */
    errorMessage?: string | undefined;
};

export type Hash = {
    /**
     * Hash of the asset
     */
    hash?: string | undefined;
    /**
     * Hash algorithm used to compute the hash
     */
    algorithm?: string | undefined;
};

/**
 * type of track
 */
export enum AssetVideoSpecType {
    Video = "video",
    Audio = "audio",
}

export type Tracks = {
    /**
     * type of track
     */
    type: AssetVideoSpecType;
    /**
     * Codec of the track
     */
    codec: string;
    /**
     * Start time of the track in seconds
     */
    startTime?: number | undefined;
    /**
     * Duration of the track in seconds
     */
    duration?: number | undefined;
    /**
     * Bitrate of the track in bits per second
     */
    bitrate?: number | undefined;
    /**
     * Width of the track - only for video tracks
     */
    width?: number | undefined;
    /**
     * Height of the track - only for video tracks
     */
    height?: number | undefined;
    /**
     * Pixel format of the track - only for video tracks
     */
    pixelFormat?: string | undefined;
    /**
     * Frame rate of the track - only for video tracks
     */
    fps?: number | undefined;
    /**
     * Amount of audio channels in the track
     */
    channels?: number | undefined;
    /**
     * Sample rate of the track in samples per second - only for
     *
     * @remarks
     * audio tracks
     *
     */
    sampleRate?: number | undefined;
    /**
     * Bit depth of the track - only for audio tracks
     */
    bitDepth?: number | undefined;
};

/**
 * Video metadata
 */
export type VideoSpec = {
    /**
     * Format of the asset
     */
    format?: string | undefined;
    /**
     * Duration of the asset in seconds (float)
     */
    duration?: number | undefined;
    /**
     * Bitrate of the video in bits per second
     */
    bitrate?: number | undefined;
    /**
     * List of tracks associated with the asset when the format
     *
     * @remarks
     * contemplates them (e.g. mp4)
     *
     */
    tracks?: Array<Tracks> | undefined;
};

export type Asset = {
    id: string;
    /**
     * Type of the asset.
     */
    type?: AssetType | undefined;
    /**
     * Used to form playback URL and storage folder
     */
    playbackId?: string | undefined;
    /**
     * URL for HLS playback
     */
    playbackUrl?: string | undefined;
    /**
     * URL to manually download the asset if desired
     */
    downloadUrl?: string | undefined;
    /**
     * Whether the playback policy for a asset or stream is public or signed
     */
    playbackPolicy?: PlaybackPolicy | undefined;
    source: Two | Source3 | AssetSource1;
    creatorId?: CreatorId | undefined;
    storage?: AssetStorage | undefined;
    /**
     * Status of the asset
     */
    status?: AssetStatus | undefined;
    /**
     * Name of the asset. This is not necessarily the filename, can be a
     *
     * @remarks
     * custom name or title
     *
     */
    name: string;
    /**
     * Timestamp (in milliseconds) at which asset was created
     */
    createdAt?: number | undefined;
    /**
     * Size of the asset in bytes
     */
    size?: number | undefined;
    /**
     * Hash of the asset
     */
    hash?: Array<Hash> | undefined;
    /**
     * Video metadata
     */
    videoSpec?: VideoSpec | undefined;
};

export type Three = {
    type: AssetSource3Type;
    encryption?: Encryption | undefined;
};

export type Source1 = {
    type: SourceType;
    /**
     * URL from which the asset was uploaded
     */
    url: string;
    /**
     * Gateway URL from asset if parsed from provided URL on upload.
     */
    gatewayUrl?: string | undefined;
    encryption?: Encryption | undefined;
};

export type Source = Two | Three | Source1;

export type AssetIpfsInput = {
    spec?: AssetSpec | undefined;
    /**
     * CID of the file on IPFS
     */
    cid?: string | undefined;
    nftMetadata?: IpfsFileInfoInput | undefined;
};

export type AssetStorageInput = {
    ipfs?: AssetIpfsInput | undefined;
};

export type AssetInput = {
    /**
     * Type of the asset.
     */
    type?: AssetType | undefined;
    /**
     * Used to form playback URL and storage folder
     */
    playbackId?: string | undefined;
    /**
     * Whether to generate MP4s for the asset.
     */
    staticMp4?: boolean | undefined;
    /**
     * Whether the playback policy for a asset or stream is public or signed
     */
    playbackPolicy?: PlaybackPolicy | undefined;
    source: Two | Three | Source1;
    creatorId?: CreatorId | undefined;
    storage?: AssetStorageInput | undefined;
    /**
     * Name of the asset. This is not necessarily the filename, can be a
     *
     * @remarks
     * custom name or title
     *
     */
    name: string;
    /**
     * Hash of the asset
     */
    hash?: Array<Hash> | undefined;
};

/** @internal */
export const AssetType$ = z.nativeEnum(AssetType);

/** @internal */
export const AssetSource3Type$ = z.nativeEnum(AssetSource3Type);

/** @internal */
export namespace Source3$ {
    export type Inbound = {
        type: AssetSource3Type;
        encryption?: EncryptionOutput$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<Source3, z.ZodTypeDef, Inbound> = z
        .object({
            type: AssetSource3Type$,
            encryption: EncryptionOutput$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });

    export type Outbound = {
        type: AssetSource3Type;
        encryption?: EncryptionOutput$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Source3> = z
        .object({
            type: AssetSource3Type$,
            encryption: EncryptionOutput$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });
}

/** @internal */
export const AssetSourceType$ = z.nativeEnum(AssetSourceType);

/** @internal */
export namespace Two$ {
    export type Inbound = {
        type: AssetSourceType;
        sessionId: string;
    };

    export const inboundSchema: z.ZodType<Two, z.ZodTypeDef, Inbound> = z
        .object({
            type: AssetSourceType$,
            sessionId: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                sessionId: v.sessionId,
            };
        });

    export type Outbound = {
        type: AssetSourceType;
        sessionId: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Two> = z
        .object({
            type: AssetSourceType$,
            sessionId: z.string(),
        })
        .transform((v) => {
            return {
                type: v.type,
                sessionId: v.sessionId,
            };
        });
}

/** @internal */
export const SourceType$ = z.nativeEnum(SourceType);

/** @internal */
export namespace AssetSource1$ {
    export type Inbound = {
        type: SourceType;
        url: string;
        gatewayUrl?: string | undefined;
        encryption?: EncryptionOutput$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<AssetSource1, z.ZodTypeDef, Inbound> = z
        .object({
            type: SourceType$,
            url: z.string(),
            gatewayUrl: z.string().optional(),
            encryption: EncryptionOutput$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                url: v.url,
                ...(v.gatewayUrl === undefined ? null : { gatewayUrl: v.gatewayUrl }),
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });

    export type Outbound = {
        type: SourceType;
        url: string;
        gatewayUrl?: string | undefined;
        encryption?: EncryptionOutput$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetSource1> = z
        .object({
            type: SourceType$,
            url: z.string(),
            gatewayUrl: z.string().optional(),
            encryption: EncryptionOutput$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                url: v.url,
                ...(v.gatewayUrl === undefined ? null : { gatewayUrl: v.gatewayUrl }),
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });
}

/** @internal */
export namespace AssetSource$ {
    export type Inbound = Two$.Inbound | Source3$.Inbound | AssetSource1$.Inbound;

    export type Outbound = Two$.Outbound | Source3$.Outbound | AssetSource1$.Outbound;

    export const inboundSchema: z.ZodType<AssetSource, z.ZodTypeDef, Inbound> = z.union([
        z.lazy(() => Two$.inboundSchema),
        z.lazy(() => Source3$.inboundSchema),
        z.lazy(() => AssetSource1$.inboundSchema),
    ]);

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetSource> = z.union([
        z.lazy(() => Two$.outboundSchema),
        z.lazy(() => Source3$.outboundSchema),
        z.lazy(() => AssetSource1$.outboundSchema),
    ]);
}

/** @internal */
export const AssetNftMetadataTemplate$ = z.nativeEnum(AssetNftMetadataTemplate);

/** @internal */
export namespace AssetNftMetadata$ {
    export type Inbound = {};

    export const inboundSchema: z.ZodType<AssetNftMetadata, z.ZodTypeDef, Inbound> = z.object({});

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetNftMetadata> = z.object({});
}

/** @internal */
export namespace AssetSpec$ {
    export type Inbound = {
        nftMetadataTemplate?: AssetNftMetadataTemplate | undefined;
        nftMetadata?: AssetNftMetadata$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<AssetSpec, z.ZodTypeDef, Inbound> = z
        .object({
            nftMetadataTemplate: AssetNftMetadataTemplate$.default(AssetNftMetadataTemplate.File),
            nftMetadata: z.lazy(() => AssetNftMetadata$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                nftMetadataTemplate: v.nftMetadataTemplate,
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
            };
        });

    export type Outbound = {
        nftMetadataTemplate: AssetNftMetadataTemplate;
        nftMetadata?: AssetNftMetadata$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetSpec> = z
        .object({
            nftMetadataTemplate: AssetNftMetadataTemplate$.default(AssetNftMetadataTemplate.File),
            nftMetadata: z.lazy(() => AssetNftMetadata$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                nftMetadataTemplate: v.nftMetadataTemplate,
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
            };
        });
}

/** @internal */
export namespace AssetIpfs$ {
    export type Inbound = {
        spec?: AssetSpec$.Inbound | undefined;
        cid?: string | undefined;
        url?: string | undefined;
        gatewayUrl?: string | undefined;
        nftMetadata?: IpfsFileInfo$.Inbound | undefined;
        updatedAt?: number | undefined;
    };

    export const inboundSchema: z.ZodType<AssetIpfs, z.ZodTypeDef, Inbound> = z
        .object({
            spec: z.lazy(() => AssetSpec$.inboundSchema).optional(),
            cid: z.string().optional(),
            url: z.string().optional(),
            gatewayUrl: z.string().optional(),
            nftMetadata: IpfsFileInfo$.inboundSchema.optional(),
            updatedAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                ...(v.spec === undefined ? null : { spec: v.spec }),
                ...(v.cid === undefined ? null : { cid: v.cid }),
                ...(v.url === undefined ? null : { url: v.url }),
                ...(v.gatewayUrl === undefined ? null : { gatewayUrl: v.gatewayUrl }),
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
                ...(v.updatedAt === undefined ? null : { updatedAt: v.updatedAt }),
            };
        });

    export type Outbound = {
        spec?: AssetSpec$.Outbound | undefined;
        cid?: string | undefined;
        url?: string | undefined;
        gatewayUrl?: string | undefined;
        nftMetadata?: IpfsFileInfo$.Outbound | undefined;
        updatedAt?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetIpfs> = z
        .object({
            spec: z.lazy(() => AssetSpec$.outboundSchema).optional(),
            cid: z.string().optional(),
            url: z.string().optional(),
            gatewayUrl: z.string().optional(),
            nftMetadata: IpfsFileInfo$.outboundSchema.optional(),
            updatedAt: z.number().optional(),
        })
        .transform((v) => {
            return {
                ...(v.spec === undefined ? null : { spec: v.spec }),
                ...(v.cid === undefined ? null : { cid: v.cid }),
                ...(v.url === undefined ? null : { url: v.url }),
                ...(v.gatewayUrl === undefined ? null : { gatewayUrl: v.gatewayUrl }),
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
                ...(v.updatedAt === undefined ? null : { updatedAt: v.updatedAt }),
            };
        });
}

/** @internal */
export namespace AssetStorage$ {
    export type Inbound = {
        ipfs?: AssetIpfs$.Inbound | undefined;
        status?: StorageStatus$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<AssetStorage, z.ZodTypeDef, Inbound> = z
        .object({
            ipfs: z.lazy(() => AssetIpfs$.inboundSchema).optional(),
            status: StorageStatus$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
                ...(v.status === undefined ? null : { status: v.status }),
            };
        });

    export type Outbound = {
        ipfs?: AssetIpfs$.Outbound | undefined;
        status?: StorageStatus$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetStorage> = z
        .object({
            ipfs: z.lazy(() => AssetIpfs$.outboundSchema).optional(),
            status: StorageStatus$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
                ...(v.status === undefined ? null : { status: v.status }),
            };
        });
}

/** @internal */
export const AssetPhase$ = z.nativeEnum(AssetPhase);

/** @internal */
export namespace AssetStatus$ {
    export type Inbound = {
        phase: AssetPhase;
        updatedAt: number;
        progress?: number | undefined;
        errorMessage?: string | undefined;
    };

    export const inboundSchema: z.ZodType<AssetStatus, z.ZodTypeDef, Inbound> = z
        .object({
            phase: AssetPhase$,
            updatedAt: z.number(),
            progress: z.number().optional(),
            errorMessage: z.string().optional(),
        })
        .transform((v) => {
            return {
                phase: v.phase,
                updatedAt: v.updatedAt,
                ...(v.progress === undefined ? null : { progress: v.progress }),
                ...(v.errorMessage === undefined ? null : { errorMessage: v.errorMessage }),
            };
        });

    export type Outbound = {
        phase: AssetPhase;
        updatedAt: number;
        progress?: number | undefined;
        errorMessage?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetStatus> = z
        .object({
            phase: AssetPhase$,
            updatedAt: z.number(),
            progress: z.number().optional(),
            errorMessage: z.string().optional(),
        })
        .transform((v) => {
            return {
                phase: v.phase,
                updatedAt: v.updatedAt,
                ...(v.progress === undefined ? null : { progress: v.progress }),
                ...(v.errorMessage === undefined ? null : { errorMessage: v.errorMessage }),
            };
        });
}

/** @internal */
export namespace Hash$ {
    export type Inbound = {
        hash?: string | undefined;
        algorithm?: string | undefined;
    };

    export const inboundSchema: z.ZodType<Hash, z.ZodTypeDef, Inbound> = z
        .object({
            hash: z.string().optional(),
            algorithm: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.hash === undefined ? null : { hash: v.hash }),
                ...(v.algorithm === undefined ? null : { algorithm: v.algorithm }),
            };
        });

    export type Outbound = {
        hash?: string | undefined;
        algorithm?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Hash> = z
        .object({
            hash: z.string().optional(),
            algorithm: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.hash === undefined ? null : { hash: v.hash }),
                ...(v.algorithm === undefined ? null : { algorithm: v.algorithm }),
            };
        });
}

/** @internal */
export const AssetVideoSpecType$ = z.nativeEnum(AssetVideoSpecType);

/** @internal */
export namespace Tracks$ {
    export type Inbound = {
        type: AssetVideoSpecType;
        codec: string;
        startTime?: number | undefined;
        duration?: number | undefined;
        bitrate?: number | undefined;
        width?: number | undefined;
        height?: number | undefined;
        pixelFormat?: string | undefined;
        fps?: number | undefined;
        channels?: number | undefined;
        sampleRate?: number | undefined;
        bitDepth?: number | undefined;
    };

    export const inboundSchema: z.ZodType<Tracks, z.ZodTypeDef, Inbound> = z
        .object({
            type: AssetVideoSpecType$,
            codec: z.string(),
            startTime: z.number().optional(),
            duration: z.number().optional(),
            bitrate: z.number().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            pixelFormat: z.string().optional(),
            fps: z.number().optional(),
            channels: z.number().optional(),
            sampleRate: z.number().optional(),
            bitDepth: z.number().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                codec: v.codec,
                ...(v.startTime === undefined ? null : { startTime: v.startTime }),
                ...(v.duration === undefined ? null : { duration: v.duration }),
                ...(v.bitrate === undefined ? null : { bitrate: v.bitrate }),
                ...(v.width === undefined ? null : { width: v.width }),
                ...(v.height === undefined ? null : { height: v.height }),
                ...(v.pixelFormat === undefined ? null : { pixelFormat: v.pixelFormat }),
                ...(v.fps === undefined ? null : { fps: v.fps }),
                ...(v.channels === undefined ? null : { channels: v.channels }),
                ...(v.sampleRate === undefined ? null : { sampleRate: v.sampleRate }),
                ...(v.bitDepth === undefined ? null : { bitDepth: v.bitDepth }),
            };
        });

    export type Outbound = {
        type: AssetVideoSpecType;
        codec: string;
        startTime?: number | undefined;
        duration?: number | undefined;
        bitrate?: number | undefined;
        width?: number | undefined;
        height?: number | undefined;
        pixelFormat?: string | undefined;
        fps?: number | undefined;
        channels?: number | undefined;
        sampleRate?: number | undefined;
        bitDepth?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Tracks> = z
        .object({
            type: AssetVideoSpecType$,
            codec: z.string(),
            startTime: z.number().optional(),
            duration: z.number().optional(),
            bitrate: z.number().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            pixelFormat: z.string().optional(),
            fps: z.number().optional(),
            channels: z.number().optional(),
            sampleRate: z.number().optional(),
            bitDepth: z.number().optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                codec: v.codec,
                ...(v.startTime === undefined ? null : { startTime: v.startTime }),
                ...(v.duration === undefined ? null : { duration: v.duration }),
                ...(v.bitrate === undefined ? null : { bitrate: v.bitrate }),
                ...(v.width === undefined ? null : { width: v.width }),
                ...(v.height === undefined ? null : { height: v.height }),
                ...(v.pixelFormat === undefined ? null : { pixelFormat: v.pixelFormat }),
                ...(v.fps === undefined ? null : { fps: v.fps }),
                ...(v.channels === undefined ? null : { channels: v.channels }),
                ...(v.sampleRate === undefined ? null : { sampleRate: v.sampleRate }),
                ...(v.bitDepth === undefined ? null : { bitDepth: v.bitDepth }),
            };
        });
}

/** @internal */
export namespace VideoSpec$ {
    export type Inbound = {
        format?: string | undefined;
        duration?: number | undefined;
        bitrate?: number | undefined;
        tracks?: Array<Tracks$.Inbound> | undefined;
    };

    export const inboundSchema: z.ZodType<VideoSpec, z.ZodTypeDef, Inbound> = z
        .object({
            format: z.string().optional(),
            duration: z.number().optional(),
            bitrate: z.number().optional(),
            tracks: z.array(z.lazy(() => Tracks$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.format === undefined ? null : { format: v.format }),
                ...(v.duration === undefined ? null : { duration: v.duration }),
                ...(v.bitrate === undefined ? null : { bitrate: v.bitrate }),
                ...(v.tracks === undefined ? null : { tracks: v.tracks }),
            };
        });

    export type Outbound = {
        format?: string | undefined;
        duration?: number | undefined;
        bitrate?: number | undefined;
        tracks?: Array<Tracks$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, VideoSpec> = z
        .object({
            format: z.string().optional(),
            duration: z.number().optional(),
            bitrate: z.number().optional(),
            tracks: z.array(z.lazy(() => Tracks$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.format === undefined ? null : { format: v.format }),
                ...(v.duration === undefined ? null : { duration: v.duration }),
                ...(v.bitrate === undefined ? null : { bitrate: v.bitrate }),
                ...(v.tracks === undefined ? null : { tracks: v.tracks }),
            };
        });
}

/** @internal */
export namespace Asset$ {
    export type Inbound = {
        id: string;
        type?: AssetType | undefined;
        playbackId?: string | undefined;
        playbackUrl?: string | undefined;
        downloadUrl?: string | undefined;
        playbackPolicy?: PlaybackPolicy$.Inbound | undefined;
        source: Two$.Inbound | Source3$.Inbound | AssetSource1$.Inbound;
        creatorId?: CreatorId$.Inbound | undefined;
        storage?: AssetStorage$.Inbound | undefined;
        status?: AssetStatus$.Inbound | undefined;
        name: string;
        createdAt?: number | undefined;
        size?: number | undefined;
        hash?: Array<Hash$.Inbound> | undefined;
        videoSpec?: VideoSpec$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<Asset, z.ZodTypeDef, Inbound> = z
        .object({
            id: z.string(),
            type: AssetType$.optional(),
            playbackId: z.string().optional(),
            playbackUrl: z.string().optional(),
            downloadUrl: z.string().optional(),
            playbackPolicy: PlaybackPolicy$.inboundSchema.optional(),
            source: z.union([
                z.lazy(() => Two$.inboundSchema),
                z.lazy(() => Source3$.inboundSchema),
                z.lazy(() => AssetSource1$.inboundSchema),
            ]),
            creatorId: CreatorId$.inboundSchema.optional(),
            storage: z.lazy(() => AssetStorage$.inboundSchema).optional(),
            status: z.lazy(() => AssetStatus$.inboundSchema).optional(),
            name: z.string(),
            createdAt: z.number().optional(),
            size: z.number().optional(),
            hash: z.array(z.lazy(() => Hash$.inboundSchema)).optional(),
            videoSpec: z.lazy(() => VideoSpec$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                id: v.id,
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.playbackId === undefined ? null : { playbackId: v.playbackId }),
                ...(v.playbackUrl === undefined ? null : { playbackUrl: v.playbackUrl }),
                ...(v.downloadUrl === undefined ? null : { downloadUrl: v.downloadUrl }),
                ...(v.playbackPolicy === undefined ? null : { playbackPolicy: v.playbackPolicy }),
                source: v.source,
                ...(v.creatorId === undefined ? null : { creatorId: v.creatorId }),
                ...(v.storage === undefined ? null : { storage: v.storage }),
                ...(v.status === undefined ? null : { status: v.status }),
                name: v.name,
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.size === undefined ? null : { size: v.size }),
                ...(v.hash === undefined ? null : { hash: v.hash }),
                ...(v.videoSpec === undefined ? null : { videoSpec: v.videoSpec }),
            };
        });

    export type Outbound = {
        id: string;
        type?: AssetType | undefined;
        playbackId?: string | undefined;
        playbackUrl?: string | undefined;
        downloadUrl?: string | undefined;
        playbackPolicy?: PlaybackPolicy$.Outbound | undefined;
        source: Two$.Outbound | Source3$.Outbound | AssetSource1$.Outbound;
        creatorId?: CreatorId$.Outbound | undefined;
        storage?: AssetStorage$.Outbound | undefined;
        status?: AssetStatus$.Outbound | undefined;
        name: string;
        createdAt?: number | undefined;
        size?: number | undefined;
        hash?: Array<Hash$.Outbound> | undefined;
        videoSpec?: VideoSpec$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Asset> = z
        .object({
            id: z.string(),
            type: AssetType$.optional(),
            playbackId: z.string().optional(),
            playbackUrl: z.string().optional(),
            downloadUrl: z.string().optional(),
            playbackPolicy: PlaybackPolicy$.outboundSchema.optional(),
            source: z.union([
                z.lazy(() => Two$.outboundSchema),
                z.lazy(() => Source3$.outboundSchema),
                z.lazy(() => AssetSource1$.outboundSchema),
            ]),
            creatorId: CreatorId$.outboundSchema.optional(),
            storage: z.lazy(() => AssetStorage$.outboundSchema).optional(),
            status: z.lazy(() => AssetStatus$.outboundSchema).optional(),
            name: z.string(),
            createdAt: z.number().optional(),
            size: z.number().optional(),
            hash: z.array(z.lazy(() => Hash$.outboundSchema)).optional(),
            videoSpec: z.lazy(() => VideoSpec$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                id: v.id,
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.playbackId === undefined ? null : { playbackId: v.playbackId }),
                ...(v.playbackUrl === undefined ? null : { playbackUrl: v.playbackUrl }),
                ...(v.downloadUrl === undefined ? null : { downloadUrl: v.downloadUrl }),
                ...(v.playbackPolicy === undefined ? null : { playbackPolicy: v.playbackPolicy }),
                source: v.source,
                ...(v.creatorId === undefined ? null : { creatorId: v.creatorId }),
                ...(v.storage === undefined ? null : { storage: v.storage }),
                ...(v.status === undefined ? null : { status: v.status }),
                name: v.name,
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.size === undefined ? null : { size: v.size }),
                ...(v.hash === undefined ? null : { hash: v.hash }),
                ...(v.videoSpec === undefined ? null : { videoSpec: v.videoSpec }),
            };
        });
}

/** @internal */
export namespace Three$ {
    export type Inbound = {
        type: AssetSource3Type;
        encryption?: Encryption$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<Three, z.ZodTypeDef, Inbound> = z
        .object({
            type: AssetSource3Type$,
            encryption: Encryption$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });

    export type Outbound = {
        type: AssetSource3Type;
        encryption?: Encryption$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Three> = z
        .object({
            type: AssetSource3Type$,
            encryption: Encryption$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });
}

/** @internal */
export namespace Source1$ {
    export type Inbound = {
        type: SourceType;
        url: string;
        gatewayUrl?: string | undefined;
        encryption?: Encryption$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<Source1, z.ZodTypeDef, Inbound> = z
        .object({
            type: SourceType$,
            url: z.string(),
            gatewayUrl: z.string().optional(),
            encryption: Encryption$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                url: v.url,
                ...(v.gatewayUrl === undefined ? null : { gatewayUrl: v.gatewayUrl }),
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });

    export type Outbound = {
        type: SourceType;
        url: string;
        gatewayUrl?: string | undefined;
        encryption?: Encryption$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Source1> = z
        .object({
            type: SourceType$,
            url: z.string(),
            gatewayUrl: z.string().optional(),
            encryption: Encryption$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                type: v.type,
                url: v.url,
                ...(v.gatewayUrl === undefined ? null : { gatewayUrl: v.gatewayUrl }),
                ...(v.encryption === undefined ? null : { encryption: v.encryption }),
            };
        });
}

/** @internal */
export namespace Source$ {
    export type Inbound = Two$.Inbound | Three$.Inbound | Source1$.Inbound;

    export type Outbound = Two$.Outbound | Three$.Outbound | Source1$.Outbound;

    export const inboundSchema: z.ZodType<Source, z.ZodTypeDef, Inbound> = z.union([
        z.lazy(() => Two$.inboundSchema),
        z.lazy(() => Three$.inboundSchema),
        z.lazy(() => Source1$.inboundSchema),
    ]);

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Source> = z.union([
        z.lazy(() => Two$.outboundSchema),
        z.lazy(() => Three$.outboundSchema),
        z.lazy(() => Source1$.outboundSchema),
    ]);
}

/** @internal */
export namespace AssetIpfsInput$ {
    export type Inbound = {
        spec?: AssetSpec$.Inbound | undefined;
        cid?: string | undefined;
        nftMetadata?: IpfsFileInfoInput$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<AssetIpfsInput, z.ZodTypeDef, Inbound> = z
        .object({
            spec: z.lazy(() => AssetSpec$.inboundSchema).optional(),
            cid: z.string().optional(),
            nftMetadata: IpfsFileInfoInput$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.spec === undefined ? null : { spec: v.spec }),
                ...(v.cid === undefined ? null : { cid: v.cid }),
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
            };
        });

    export type Outbound = {
        spec?: AssetSpec$.Outbound | undefined;
        cid?: string | undefined;
        nftMetadata?: IpfsFileInfoInput$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetIpfsInput> = z
        .object({
            spec: z.lazy(() => AssetSpec$.outboundSchema).optional(),
            cid: z.string().optional(),
            nftMetadata: IpfsFileInfoInput$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.spec === undefined ? null : { spec: v.spec }),
                ...(v.cid === undefined ? null : { cid: v.cid }),
                ...(v.nftMetadata === undefined ? null : { nftMetadata: v.nftMetadata }),
            };
        });
}

/** @internal */
export namespace AssetStorageInput$ {
    export type Inbound = {
        ipfs?: AssetIpfsInput$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<AssetStorageInput, z.ZodTypeDef, Inbound> = z
        .object({
            ipfs: z.lazy(() => AssetIpfsInput$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
            };
        });

    export type Outbound = {
        ipfs?: AssetIpfsInput$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetStorageInput> = z
        .object({
            ipfs: z.lazy(() => AssetIpfsInput$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ...(v.ipfs === undefined ? null : { ipfs: v.ipfs }),
            };
        });
}

/** @internal */
export namespace AssetInput$ {
    export type Inbound = {
        type?: AssetType | undefined;
        playbackId?: string | undefined;
        staticMp4?: boolean | undefined;
        playbackPolicy?: PlaybackPolicy$.Inbound | undefined;
        source: Two$.Inbound | Three$.Inbound | Source1$.Inbound;
        creatorId?: CreatorId$.Inbound | undefined;
        storage?: AssetStorageInput$.Inbound | undefined;
        name: string;
        hash?: Array<Hash$.Inbound> | undefined;
    };

    export const inboundSchema: z.ZodType<AssetInput, z.ZodTypeDef, Inbound> = z
        .object({
            type: AssetType$.optional(),
            playbackId: z.string().optional(),
            staticMp4: z.boolean().optional(),
            playbackPolicy: PlaybackPolicy$.inboundSchema.optional(),
            source: z.union([
                z.lazy(() => Two$.inboundSchema),
                z.lazy(() => Three$.inboundSchema),
                z.lazy(() => Source1$.inboundSchema),
            ]),
            creatorId: CreatorId$.inboundSchema.optional(),
            storage: z.lazy(() => AssetStorageInput$.inboundSchema).optional(),
            name: z.string(),
            hash: z.array(z.lazy(() => Hash$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.playbackId === undefined ? null : { playbackId: v.playbackId }),
                ...(v.staticMp4 === undefined ? null : { staticMp4: v.staticMp4 }),
                ...(v.playbackPolicy === undefined ? null : { playbackPolicy: v.playbackPolicy }),
                source: v.source,
                ...(v.creatorId === undefined ? null : { creatorId: v.creatorId }),
                ...(v.storage === undefined ? null : { storage: v.storage }),
                name: v.name,
                ...(v.hash === undefined ? null : { hash: v.hash }),
            };
        });

    export type Outbound = {
        type?: AssetType | undefined;
        playbackId?: string | undefined;
        staticMp4?: boolean | undefined;
        playbackPolicy?: PlaybackPolicy$.Outbound | undefined;
        source: Two$.Outbound | Three$.Outbound | Source1$.Outbound;
        creatorId?: CreatorId$.Outbound | undefined;
        storage?: AssetStorageInput$.Outbound | undefined;
        name: string;
        hash?: Array<Hash$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssetInput> = z
        .object({
            type: AssetType$.optional(),
            playbackId: z.string().optional(),
            staticMp4: z.boolean().optional(),
            playbackPolicy: PlaybackPolicy$.outboundSchema.optional(),
            source: z.union([
                z.lazy(() => Two$.outboundSchema),
                z.lazy(() => Three$.outboundSchema),
                z.lazy(() => Source1$.outboundSchema),
            ]),
            creatorId: CreatorId$.outboundSchema.optional(),
            storage: z.lazy(() => AssetStorageInput$.outboundSchema).optional(),
            name: z.string(),
            hash: z.array(z.lazy(() => Hash$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.playbackId === undefined ? null : { playbackId: v.playbackId }),
                ...(v.staticMp4 === undefined ? null : { staticMp4: v.staticMp4 }),
                ...(v.playbackPolicy === undefined ? null : { playbackPolicy: v.playbackPolicy }),
                source: v.source,
                ...(v.creatorId === undefined ? null : { creatorId: v.creatorId }),
                ...(v.storage === undefined ? null : { storage: v.storage }),
                name: v.name,
                ...(v.hash === undefined ? null : { hash: v.hash }),
            };
        });
}
