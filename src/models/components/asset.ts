/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  CreatorId,
  CreatorId$inboundSchema,
  CreatorId$Outbound,
  CreatorId$outboundSchema,
} from "./creatorid.js";
import {
  EncryptionOutput,
  EncryptionOutput$inboundSchema,
  EncryptionOutput$Outbound,
  EncryptionOutput$outboundSchema,
} from "./encryptionoutput.js";
import {
  IpfsFileInfo,
  IpfsFileInfo$inboundSchema,
  IpfsFileInfo$Outbound,
  IpfsFileInfo$outboundSchema,
} from "./ipfsfileinfo.js";
import {
  PlaybackPolicy,
  PlaybackPolicy$inboundSchema,
  PlaybackPolicy$Outbound,
  PlaybackPolicy$outboundSchema,
} from "./playbackpolicy.js";
import {
  StorageStatus,
  StorageStatus$inboundSchema,
  StorageStatus$Outbound,
  StorageStatus$outboundSchema,
} from "./storagestatus.js";
import {
  TranscodeProfile,
  TranscodeProfile$inboundSchema,
  TranscodeProfile$Outbound,
  TranscodeProfile$outboundSchema,
} from "./transcodeprofile.js";

/**
 * Type of the asset.
 */
export enum AssetType {
  Video = "video",
  Audio = "audio",
}

export enum AssetSchemasSource3Type {
  DirectUpload = "directUpload",
  Clip = "clip",
}

export type Asset3 = {
  type: AssetSchemasSource3Type;
  encryption?: EncryptionOutput | undefined;
  /**
   * ID of the asset or stream from which this asset was created.
   */
  sourceId?: string | undefined;
  /**
   * ID of the session from which this asset was created.
   */
  sessionId?: string | undefined;
  /**
   * Playback ID of the asset or stream from which this asset was created.
   */
  playbackId?: string | undefined;
  /**
   * ID of the requester from which this asset was created.
   */
  requesterId?: string | undefined;
  /**
   * ID of the asset from which this asset was created.
   */
  assetId?: string | undefined;
};

export enum AssetSchemasSourceType {
  Recording = "recording",
}

export type Two = {
  type: AssetSchemasSourceType;
  /**
   * ID of the session from which this asset was created
   */
  sessionId: string;
};

export enum AssetSchemasType {
  Url = "url",
}

export type Asset1 = {
  type: AssetSchemasType;
  /**
   * URL from which the asset was uploaded.
   */
  url: string;
  /**
   * Gateway URL from asset if parsed from provided URL on upload.
   */
  gatewayUrl?: string | undefined;
  encryption?: EncryptionOutput | undefined;
};

export type Source = Two | Asset1 | Asset3;

/**
 * Name of the NFT metadata template to export. 'player'
 *
 * @remarks
 * will embed the Livepeer Player on the NFT while 'file'
 * will reference only the immutable MP4 files.
 */
export enum AssetNftMetadataTemplate {
  File = "file",
  Player = "player",
}

/**
 * Additional data to add to the NFT metadata exported to
 *
 * @remarks
 * IPFS. Will be deep merged with the default metadata
 * exported.
 */
export type AssetNftMetadata = {};

export type AssetSpec = {
  /**
   * Name of the NFT metadata template to export. 'player'
   *
   * @remarks
   * will embed the Livepeer Player on the NFT while 'file'
   * will reference only the immutable MP4 files.
   */
  nftMetadataTemplate?: AssetNftMetadataTemplate | undefined;
  /**
   * Additional data to add to the NFT metadata exported to
   *
   * @remarks
   * IPFS. Will be deep merged with the default metadata
   * exported.
   */
  nftMetadata?: AssetNftMetadata | undefined;
};

export type AssetIpfs = {
  spec?: AssetSpec | undefined;
  dollarRef?: any | undefined;
  nftMetadata?: IpfsFileInfo | undefined;
  /**
   * Timestamp (in milliseconds) at which IPFS export task was
   *
   * @remarks
   * updated
   */
  updatedAt?: number | undefined;
};

export type AssetStorage = {
  ipfs?: AssetIpfs | undefined;
  status?: StorageStatus | undefined;
};

/**
 * Phase of the asset
 */
export enum AssetPhase {
  Uploading = "uploading",
  Waiting = "waiting",
  Processing = "processing",
  Ready = "ready",
  Failed = "failed",
  Deleting = "deleting",
  Deleted = "deleted",
}

/**
 * Status of the asset
 */
export type AssetStatus = {
  /**
   * Phase of the asset
   */
  phase: AssetPhase;
  /**
   * Timestamp (in milliseconds) at which the asset was last updated
   */
  updatedAt: number;
  /**
   * Current progress of the task creating this asset.
   */
  progress?: number | undefined;
  /**
   * Error message if the asset creation failed.
   */
  errorMessage?: string | undefined;
};

export type Hash = {
  /**
   * Hash of the asset
   */
  hash?: string | undefined;
  /**
   * Hash algorithm used to compute the hash
   */
  algorithm?: string | undefined;
};

/**
 * type of track
 */
export enum AssetSchemasVideoSpecType {
  Video = "video",
  Audio = "audio",
}

export type Tracks = {
  /**
   * type of track
   */
  type: AssetSchemasVideoSpecType;
  /**
   * Codec of the track
   */
  codec: string;
  /**
   * Start time of the track in seconds
   */
  startTime?: number | undefined;
  /**
   * Duration of the track in seconds
   */
  duration?: number | undefined;
  /**
   * Bitrate of the track in bits per second
   */
  bitrate?: number | undefined;
  /**
   * Width of the track - only for video tracks
   */
  width?: number | undefined;
  /**
   * Height of the track - only for video tracks
   */
  height?: number | undefined;
  /**
   * Pixel format of the track - only for video tracks
   */
  pixelFormat?: string | undefined;
  /**
   * Frame rate of the track - only for video tracks
   */
  fps?: number | undefined;
  /**
   * Amount of audio channels in the track
   */
  channels?: number | undefined;
  /**
   * Sample rate of the track in samples per second - only for
   *
   * @remarks
   * audio tracks
   */
  sampleRate?: number | undefined;
  /**
   * Bit depth of the track - only for audio tracks
   */
  bitDepth?: number | undefined;
};

/**
 * Video metadata
 */
export type VideoSpec = {
  /**
   * Format of the asset
   */
  format?: string | undefined;
  /**
   * Duration of the asset in seconds (float)
   */
  duration?: number | undefined;
  /**
   * Bitrate of the video in bits per second
   */
  bitrate?: number | undefined;
  /**
   * List of tracks associated with the asset when the format
   *
   * @remarks
   * contemplates them (e.g. mp4)
   */
  tracks?: Array<Tracks> | undefined;
};

export type Asset = {
  id: string;
  /**
   * Type of the asset.
   */
  type?: AssetType | undefined;
  /**
   * The playback ID to use with the Playback Info endpoint to retrieve playback URLs.
   */
  playbackId?: string | undefined;
  /**
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  userId?: string | undefined;
  /**
   * URL for HLS playback. **It is recommended to not use this URL**, and instead use playback IDs with the Playback Info endpoint to retrieve the playback URLs - this URL format is subject to change (e.g. https://livepeercdn.com/asset/ea03f37e-f861-4cdd-b495-0e60b6d753ad/index.m3u8).
   */
  playbackUrl?: string | undefined;
  /**
   * The URL to directly download the asset, e.g. `https://livepeercdn.com/asset/eawrrk06ts2d0mzb/video`. It is not recommended to use this for playback.
   */
  downloadUrl?: string | undefined;
  /**
   * Whether the playback policy for an asset or stream is public or signed
   */
  playbackPolicy?: PlaybackPolicy | null | undefined;
  source: Two | Asset1 | Asset3;
  creatorId?: CreatorId | undefined;
  /**
   * Requested profiles for the asset to be transcoded into. Configured
   *
   * @remarks
   * on the upload APIs payload or through the `stream.recordingSpec`
   * field for recordings. If not specified, default profiles are derived
   * based on the source input. If this is a recording, the source will
   * not be present in this list but will be available for playback.
   */
  profiles?: Array<TranscodeProfile> | undefined;
  storage?: AssetStorage | undefined;
  /**
   * Status of the asset
   */
  status?: AssetStatus | undefined;
  /**
   * The name of the asset. This is not necessarily the filename - it can be a custom name or title.
   *
   * @remarks
   */
  name: string;
  /**
   * The ID of the project
   */
  projectId?: string | undefined;
  /**
   * Timestamp (in milliseconds) at which asset was created
   */
  createdAt?: number | undefined;
  /**
   * Name of the token used to create this object
   */
  createdByTokenName?: string | undefined;
  /**
   * Size of the asset in bytes
   */
  size?: number | undefined;
  /**
   * Hash of the asset
   */
  hash?: Array<Hash> | null | undefined;
  /**
   * Video metadata
   */
  videoSpec?: VideoSpec | undefined;
};

/** @internal */
export const AssetType$inboundSchema: z.ZodNativeEnum<typeof AssetType> = z
  .nativeEnum(AssetType);

/** @internal */
export const AssetType$outboundSchema: z.ZodNativeEnum<typeof AssetType> =
  AssetType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetType$ {
  /** @deprecated use `AssetType$inboundSchema` instead. */
  export const inboundSchema = AssetType$inboundSchema;
  /** @deprecated use `AssetType$outboundSchema` instead. */
  export const outboundSchema = AssetType$outboundSchema;
}

/** @internal */
export const AssetSchemasSource3Type$inboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasSource3Type
> = z.nativeEnum(AssetSchemasSource3Type);

/** @internal */
export const AssetSchemasSource3Type$outboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasSource3Type
> = AssetSchemasSource3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetSchemasSource3Type$ {
  /** @deprecated use `AssetSchemasSource3Type$inboundSchema` instead. */
  export const inboundSchema = AssetSchemasSource3Type$inboundSchema;
  /** @deprecated use `AssetSchemasSource3Type$outboundSchema` instead. */
  export const outboundSchema = AssetSchemasSource3Type$outboundSchema;
}

/** @internal */
export const Asset3$inboundSchema: z.ZodType<Asset3, z.ZodTypeDef, unknown> = z
  .object({
    type: AssetSchemasSource3Type$inboundSchema,
    encryption: EncryptionOutput$inboundSchema.optional(),
    sourceId: z.string().optional(),
    sessionId: z.string().optional(),
    playbackId: z.string().optional(),
    requesterId: z.string().optional(),
    assetId: z.string().optional(),
  });

/** @internal */
export type Asset3$Outbound = {
  type: string;
  encryption?: EncryptionOutput$Outbound | undefined;
  sourceId?: string | undefined;
  sessionId?: string | undefined;
  playbackId?: string | undefined;
  requesterId?: string | undefined;
  assetId?: string | undefined;
};

/** @internal */
export const Asset3$outboundSchema: z.ZodType<
  Asset3$Outbound,
  z.ZodTypeDef,
  Asset3
> = z.object({
  type: AssetSchemasSource3Type$outboundSchema,
  encryption: EncryptionOutput$outboundSchema.optional(),
  sourceId: z.string().optional(),
  sessionId: z.string().optional(),
  playbackId: z.string().optional(),
  requesterId: z.string().optional(),
  assetId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Asset3$ {
  /** @deprecated use `Asset3$inboundSchema` instead. */
  export const inboundSchema = Asset3$inboundSchema;
  /** @deprecated use `Asset3$outboundSchema` instead. */
  export const outboundSchema = Asset3$outboundSchema;
  /** @deprecated use `Asset3$Outbound` instead. */
  export type Outbound = Asset3$Outbound;
}

/** @internal */
export const AssetSchemasSourceType$inboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasSourceType
> = z.nativeEnum(AssetSchemasSourceType);

/** @internal */
export const AssetSchemasSourceType$outboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasSourceType
> = AssetSchemasSourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetSchemasSourceType$ {
  /** @deprecated use `AssetSchemasSourceType$inboundSchema` instead. */
  export const inboundSchema = AssetSchemasSourceType$inboundSchema;
  /** @deprecated use `AssetSchemasSourceType$outboundSchema` instead. */
  export const outboundSchema = AssetSchemasSourceType$outboundSchema;
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    type: AssetSchemasSourceType$inboundSchema,
    sessionId: z.string(),
  });

/** @internal */
export type Two$Outbound = {
  type: string;
  sessionId: string;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    type: AssetSchemasSourceType$outboundSchema,
    sessionId: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

/** @internal */
export const AssetSchemasType$inboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasType
> = z.nativeEnum(AssetSchemasType);

/** @internal */
export const AssetSchemasType$outboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasType
> = AssetSchemasType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetSchemasType$ {
  /** @deprecated use `AssetSchemasType$inboundSchema` instead. */
  export const inboundSchema = AssetSchemasType$inboundSchema;
  /** @deprecated use `AssetSchemasType$outboundSchema` instead. */
  export const outboundSchema = AssetSchemasType$outboundSchema;
}

/** @internal */
export const Asset1$inboundSchema: z.ZodType<Asset1, z.ZodTypeDef, unknown> = z
  .object({
    type: AssetSchemasType$inboundSchema,
    url: z.string(),
    gatewayUrl: z.string().optional(),
    encryption: EncryptionOutput$inboundSchema.optional(),
  });

/** @internal */
export type Asset1$Outbound = {
  type: string;
  url: string;
  gatewayUrl?: string | undefined;
  encryption?: EncryptionOutput$Outbound | undefined;
};

/** @internal */
export const Asset1$outboundSchema: z.ZodType<
  Asset1$Outbound,
  z.ZodTypeDef,
  Asset1
> = z.object({
  type: AssetSchemasType$outboundSchema,
  url: z.string(),
  gatewayUrl: z.string().optional(),
  encryption: EncryptionOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Asset1$ {
  /** @deprecated use `Asset1$inboundSchema` instead. */
  export const inboundSchema = Asset1$inboundSchema;
  /** @deprecated use `Asset1$outboundSchema` instead. */
  export const outboundSchema = Asset1$outboundSchema;
  /** @deprecated use `Asset1$Outbound` instead. */
  export type Outbound = Asset1$Outbound;
}

/** @internal */
export const Source$inboundSchema: z.ZodType<Source, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Two$inboundSchema),
    z.lazy(() => Asset1$inboundSchema),
    z.lazy(() => Asset3$inboundSchema),
  ]);

/** @internal */
export type Source$Outbound = Two$Outbound | Asset1$Outbound | Asset3$Outbound;

/** @internal */
export const Source$outboundSchema: z.ZodType<
  Source$Outbound,
  z.ZodTypeDef,
  Source
> = z.union([
  z.lazy(() => Two$outboundSchema),
  z.lazy(() => Asset1$outboundSchema),
  z.lazy(() => Asset3$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Source$ {
  /** @deprecated use `Source$inboundSchema` instead. */
  export const inboundSchema = Source$inboundSchema;
  /** @deprecated use `Source$outboundSchema` instead. */
  export const outboundSchema = Source$outboundSchema;
  /** @deprecated use `Source$Outbound` instead. */
  export type Outbound = Source$Outbound;
}

/** @internal */
export const AssetNftMetadataTemplate$inboundSchema: z.ZodNativeEnum<
  typeof AssetNftMetadataTemplate
> = z.nativeEnum(AssetNftMetadataTemplate);

/** @internal */
export const AssetNftMetadataTemplate$outboundSchema: z.ZodNativeEnum<
  typeof AssetNftMetadataTemplate
> = AssetNftMetadataTemplate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetNftMetadataTemplate$ {
  /** @deprecated use `AssetNftMetadataTemplate$inboundSchema` instead. */
  export const inboundSchema = AssetNftMetadataTemplate$inboundSchema;
  /** @deprecated use `AssetNftMetadataTemplate$outboundSchema` instead. */
  export const outboundSchema = AssetNftMetadataTemplate$outboundSchema;
}

/** @internal */
export const AssetNftMetadata$inboundSchema: z.ZodType<
  AssetNftMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type AssetNftMetadata$Outbound = {};

/** @internal */
export const AssetNftMetadata$outboundSchema: z.ZodType<
  AssetNftMetadata$Outbound,
  z.ZodTypeDef,
  AssetNftMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetNftMetadata$ {
  /** @deprecated use `AssetNftMetadata$inboundSchema` instead. */
  export const inboundSchema = AssetNftMetadata$inboundSchema;
  /** @deprecated use `AssetNftMetadata$outboundSchema` instead. */
  export const outboundSchema = AssetNftMetadata$outboundSchema;
  /** @deprecated use `AssetNftMetadata$Outbound` instead. */
  export type Outbound = AssetNftMetadata$Outbound;
}

/** @internal */
export const AssetSpec$inboundSchema: z.ZodType<
  AssetSpec,
  z.ZodTypeDef,
  unknown
> = z.object({
  nftMetadataTemplate: AssetNftMetadataTemplate$inboundSchema.default(
    AssetNftMetadataTemplate.File,
  ),
  nftMetadata: z.lazy(() => AssetNftMetadata$inboundSchema).optional(),
});

/** @internal */
export type AssetSpec$Outbound = {
  nftMetadataTemplate: string;
  nftMetadata?: AssetNftMetadata$Outbound | undefined;
};

/** @internal */
export const AssetSpec$outboundSchema: z.ZodType<
  AssetSpec$Outbound,
  z.ZodTypeDef,
  AssetSpec
> = z.object({
  nftMetadataTemplate: AssetNftMetadataTemplate$outboundSchema.default(
    AssetNftMetadataTemplate.File,
  ),
  nftMetadata: z.lazy(() => AssetNftMetadata$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetSpec$ {
  /** @deprecated use `AssetSpec$inboundSchema` instead. */
  export const inboundSchema = AssetSpec$inboundSchema;
  /** @deprecated use `AssetSpec$outboundSchema` instead. */
  export const outboundSchema = AssetSpec$outboundSchema;
  /** @deprecated use `AssetSpec$Outbound` instead. */
  export type Outbound = AssetSpec$Outbound;
}

/** @internal */
export const AssetIpfs$inboundSchema: z.ZodType<
  AssetIpfs,
  z.ZodTypeDef,
  unknown
> = z.object({
  spec: z.lazy(() => AssetSpec$inboundSchema).optional(),
  $ref: z.any().optional(),
  nftMetadata: IpfsFileInfo$inboundSchema.optional(),
  updatedAt: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "$ref": "dollarRef",
  });
});

/** @internal */
export type AssetIpfs$Outbound = {
  spec?: AssetSpec$Outbound | undefined;
  $ref?: any | undefined;
  nftMetadata?: IpfsFileInfo$Outbound | undefined;
  updatedAt?: number | undefined;
};

/** @internal */
export const AssetIpfs$outboundSchema: z.ZodType<
  AssetIpfs$Outbound,
  z.ZodTypeDef,
  AssetIpfs
> = z.object({
  spec: z.lazy(() => AssetSpec$outboundSchema).optional(),
  dollarRef: z.any().optional(),
  nftMetadata: IpfsFileInfo$outboundSchema.optional(),
  updatedAt: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    dollarRef: "$ref",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetIpfs$ {
  /** @deprecated use `AssetIpfs$inboundSchema` instead. */
  export const inboundSchema = AssetIpfs$inboundSchema;
  /** @deprecated use `AssetIpfs$outboundSchema` instead. */
  export const outboundSchema = AssetIpfs$outboundSchema;
  /** @deprecated use `AssetIpfs$Outbound` instead. */
  export type Outbound = AssetIpfs$Outbound;
}

/** @internal */
export const AssetStorage$inboundSchema: z.ZodType<
  AssetStorage,
  z.ZodTypeDef,
  unknown
> = z.object({
  ipfs: z.lazy(() => AssetIpfs$inboundSchema).optional(),
  status: StorageStatus$inboundSchema.optional(),
});

/** @internal */
export type AssetStorage$Outbound = {
  ipfs?: AssetIpfs$Outbound | undefined;
  status?: StorageStatus$Outbound | undefined;
};

/** @internal */
export const AssetStorage$outboundSchema: z.ZodType<
  AssetStorage$Outbound,
  z.ZodTypeDef,
  AssetStorage
> = z.object({
  ipfs: z.lazy(() => AssetIpfs$outboundSchema).optional(),
  status: StorageStatus$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetStorage$ {
  /** @deprecated use `AssetStorage$inboundSchema` instead. */
  export const inboundSchema = AssetStorage$inboundSchema;
  /** @deprecated use `AssetStorage$outboundSchema` instead. */
  export const outboundSchema = AssetStorage$outboundSchema;
  /** @deprecated use `AssetStorage$Outbound` instead. */
  export type Outbound = AssetStorage$Outbound;
}

/** @internal */
export const AssetPhase$inboundSchema: z.ZodNativeEnum<typeof AssetPhase> = z
  .nativeEnum(AssetPhase);

/** @internal */
export const AssetPhase$outboundSchema: z.ZodNativeEnum<typeof AssetPhase> =
  AssetPhase$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetPhase$ {
  /** @deprecated use `AssetPhase$inboundSchema` instead. */
  export const inboundSchema = AssetPhase$inboundSchema;
  /** @deprecated use `AssetPhase$outboundSchema` instead. */
  export const outboundSchema = AssetPhase$outboundSchema;
}

/** @internal */
export const AssetStatus$inboundSchema: z.ZodType<
  AssetStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  phase: AssetPhase$inboundSchema,
  updatedAt: z.number(),
  progress: z.number().optional(),
  errorMessage: z.string().optional(),
});

/** @internal */
export type AssetStatus$Outbound = {
  phase: string;
  updatedAt: number;
  progress?: number | undefined;
  errorMessage?: string | undefined;
};

/** @internal */
export const AssetStatus$outboundSchema: z.ZodType<
  AssetStatus$Outbound,
  z.ZodTypeDef,
  AssetStatus
> = z.object({
  phase: AssetPhase$outboundSchema,
  updatedAt: z.number(),
  progress: z.number().optional(),
  errorMessage: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetStatus$ {
  /** @deprecated use `AssetStatus$inboundSchema` instead. */
  export const inboundSchema = AssetStatus$inboundSchema;
  /** @deprecated use `AssetStatus$outboundSchema` instead. */
  export const outboundSchema = AssetStatus$outboundSchema;
  /** @deprecated use `AssetStatus$Outbound` instead. */
  export type Outbound = AssetStatus$Outbound;
}

/** @internal */
export const Hash$inboundSchema: z.ZodType<Hash, z.ZodTypeDef, unknown> = z
  .object({
    hash: z.string().optional(),
    algorithm: z.string().optional(),
  });

/** @internal */
export type Hash$Outbound = {
  hash?: string | undefined;
  algorithm?: string | undefined;
};

/** @internal */
export const Hash$outboundSchema: z.ZodType<Hash$Outbound, z.ZodTypeDef, Hash> =
  z.object({
    hash: z.string().optional(),
    algorithm: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Hash$ {
  /** @deprecated use `Hash$inboundSchema` instead. */
  export const inboundSchema = Hash$inboundSchema;
  /** @deprecated use `Hash$outboundSchema` instead. */
  export const outboundSchema = Hash$outboundSchema;
  /** @deprecated use `Hash$Outbound` instead. */
  export type Outbound = Hash$Outbound;
}

/** @internal */
export const AssetSchemasVideoSpecType$inboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasVideoSpecType
> = z.nativeEnum(AssetSchemasVideoSpecType);

/** @internal */
export const AssetSchemasVideoSpecType$outboundSchema: z.ZodNativeEnum<
  typeof AssetSchemasVideoSpecType
> = AssetSchemasVideoSpecType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssetSchemasVideoSpecType$ {
  /** @deprecated use `AssetSchemasVideoSpecType$inboundSchema` instead. */
  export const inboundSchema = AssetSchemasVideoSpecType$inboundSchema;
  /** @deprecated use `AssetSchemasVideoSpecType$outboundSchema` instead. */
  export const outboundSchema = AssetSchemasVideoSpecType$outboundSchema;
}

/** @internal */
export const Tracks$inboundSchema: z.ZodType<Tracks, z.ZodTypeDef, unknown> = z
  .object({
    type: AssetSchemasVideoSpecType$inboundSchema,
    codec: z.string(),
    startTime: z.number().optional(),
    duration: z.number().optional(),
    bitrate: z.number().optional(),
    width: z.number().optional(),
    height: z.number().optional(),
    pixelFormat: z.string().optional(),
    fps: z.number().optional(),
    channels: z.number().optional(),
    sampleRate: z.number().optional(),
    bitDepth: z.number().optional(),
  });

/** @internal */
export type Tracks$Outbound = {
  type: string;
  codec: string;
  startTime?: number | undefined;
  duration?: number | undefined;
  bitrate?: number | undefined;
  width?: number | undefined;
  height?: number | undefined;
  pixelFormat?: string | undefined;
  fps?: number | undefined;
  channels?: number | undefined;
  sampleRate?: number | undefined;
  bitDepth?: number | undefined;
};

/** @internal */
export const Tracks$outboundSchema: z.ZodType<
  Tracks$Outbound,
  z.ZodTypeDef,
  Tracks
> = z.object({
  type: AssetSchemasVideoSpecType$outboundSchema,
  codec: z.string(),
  startTime: z.number().optional(),
  duration: z.number().optional(),
  bitrate: z.number().optional(),
  width: z.number().optional(),
  height: z.number().optional(),
  pixelFormat: z.string().optional(),
  fps: z.number().optional(),
  channels: z.number().optional(),
  sampleRate: z.number().optional(),
  bitDepth: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tracks$ {
  /** @deprecated use `Tracks$inboundSchema` instead. */
  export const inboundSchema = Tracks$inboundSchema;
  /** @deprecated use `Tracks$outboundSchema` instead. */
  export const outboundSchema = Tracks$outboundSchema;
  /** @deprecated use `Tracks$Outbound` instead. */
  export type Outbound = Tracks$Outbound;
}

/** @internal */
export const VideoSpec$inboundSchema: z.ZodType<
  VideoSpec,
  z.ZodTypeDef,
  unknown
> = z.object({
  format: z.string().optional(),
  duration: z.number().optional(),
  bitrate: z.number().optional(),
  tracks: z.array(z.lazy(() => Tracks$inboundSchema)).optional(),
});

/** @internal */
export type VideoSpec$Outbound = {
  format?: string | undefined;
  duration?: number | undefined;
  bitrate?: number | undefined;
  tracks?: Array<Tracks$Outbound> | undefined;
};

/** @internal */
export const VideoSpec$outboundSchema: z.ZodType<
  VideoSpec$Outbound,
  z.ZodTypeDef,
  VideoSpec
> = z.object({
  format: z.string().optional(),
  duration: z.number().optional(),
  bitrate: z.number().optional(),
  tracks: z.array(z.lazy(() => Tracks$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace VideoSpec$ {
  /** @deprecated use `VideoSpec$inboundSchema` instead. */
  export const inboundSchema = VideoSpec$inboundSchema;
  /** @deprecated use `VideoSpec$outboundSchema` instead. */
  export const outboundSchema = VideoSpec$outboundSchema;
  /** @deprecated use `VideoSpec$Outbound` instead. */
  export type Outbound = VideoSpec$Outbound;
}

/** @internal */
export const Asset$inboundSchema: z.ZodType<Asset, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    type: AssetType$inboundSchema.optional(),
    playbackId: z.string().optional(),
    userId: z.string().optional(),
    playbackUrl: z.string().optional(),
    downloadUrl: z.string().optional(),
    playbackPolicy: z.nullable(PlaybackPolicy$inboundSchema).optional(),
    source: z.union([
      z.lazy(() => Two$inboundSchema),
      z.lazy(() => Asset1$inboundSchema),
      z.lazy(() => Asset3$inboundSchema),
    ]),
    creatorId: CreatorId$inboundSchema.optional(),
    profiles: z.array(TranscodeProfile$inboundSchema).optional(),
    storage: z.lazy(() => AssetStorage$inboundSchema).optional(),
    status: z.lazy(() => AssetStatus$inboundSchema).optional(),
    name: z.string(),
    projectId: z.string().optional(),
    createdAt: z.number().optional(),
    createdByTokenName: z.string().optional(),
    size: z.number().optional(),
    hash: z.nullable(z.array(z.lazy(() => Hash$inboundSchema))).optional(),
    videoSpec: z.lazy(() => VideoSpec$inboundSchema).optional(),
  });

/** @internal */
export type Asset$Outbound = {
  id: string;
  type?: string | undefined;
  playbackId?: string | undefined;
  userId?: string | undefined;
  playbackUrl?: string | undefined;
  downloadUrl?: string | undefined;
  playbackPolicy?: PlaybackPolicy$Outbound | null | undefined;
  source: Two$Outbound | Asset1$Outbound | Asset3$Outbound;
  creatorId?: CreatorId$Outbound | undefined;
  profiles?: Array<TranscodeProfile$Outbound> | undefined;
  storage?: AssetStorage$Outbound | undefined;
  status?: AssetStatus$Outbound | undefined;
  name: string;
  projectId?: string | undefined;
  createdAt?: number | undefined;
  createdByTokenName?: string | undefined;
  size?: number | undefined;
  hash?: Array<Hash$Outbound> | null | undefined;
  videoSpec?: VideoSpec$Outbound | undefined;
};

/** @internal */
export const Asset$outboundSchema: z.ZodType<
  Asset$Outbound,
  z.ZodTypeDef,
  Asset
> = z.object({
  id: z.string(),
  type: AssetType$outboundSchema.optional(),
  playbackId: z.string().optional(),
  userId: z.string().optional(),
  playbackUrl: z.string().optional(),
  downloadUrl: z.string().optional(),
  playbackPolicy: z.nullable(PlaybackPolicy$outboundSchema).optional(),
  source: z.union([
    z.lazy(() => Two$outboundSchema),
    z.lazy(() => Asset1$outboundSchema),
    z.lazy(() => Asset3$outboundSchema),
  ]),
  creatorId: CreatorId$outboundSchema.optional(),
  profiles: z.array(TranscodeProfile$outboundSchema).optional(),
  storage: z.lazy(() => AssetStorage$outboundSchema).optional(),
  status: z.lazy(() => AssetStatus$outboundSchema).optional(),
  name: z.string(),
  projectId: z.string().optional(),
  createdAt: z.number().optional(),
  createdByTokenName: z.string().optional(),
  size: z.number().optional(),
  hash: z.nullable(z.array(z.lazy(() => Hash$outboundSchema))).optional(),
  videoSpec: z.lazy(() => VideoSpec$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Asset$ {
  /** @deprecated use `Asset$inboundSchema` instead. */
  export const inboundSchema = Asset$inboundSchema;
  /** @deprecated use `Asset$outboundSchema` instead. */
  export const outboundSchema = Asset$outboundSchema;
  /** @deprecated use `Asset$Outbound` instead. */
  export type Outbound = Asset$Outbound;
}
