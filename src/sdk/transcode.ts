/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as components from "../models/components";
import * as errors from "../models/errors";
import * as operations from "../models/operations";
import { SDKConfiguration } from "./sdk";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse, RawAxiosRequestHeaders } from "axios";

export class Transcode {
    private sdkConfiguration: SDKConfiguration;

    constructor(sdkConfig: SDKConfiguration) {
        this.sdkConfiguration = sdkConfig;
    }

    /**
     * Transcode a video
     *
     * @remarks
     * `POST /transcode` transcodes a video file and uploads the results to the
     * specified storage service.
     * \
     * \
     * Transcoding is asynchronous so you will need to check the status of the
     * task in order to determine when transcoding is complete. The `id` field
     * in the response is the unique ID for the transcoding `Task`. The task
     * status can be queried using the [GET tasks
     * endpoint](https://docs.livepeer.org/reference/api/get-tasks):
     * \
     * \
     * When `status.phase` is `completed`,  transcoding will be complete and
     * the results will be stored in the storage service and the specified
     * output location.
     * \
     * \
     * The results will be available under `params.outputs.hls.path` and
     * `params.outputs.mp4.path` in the specified storage service.
     * ## Input
     * \
     * This endpoint currently supports the following inputs:
     * - HTTP
     * - S3 API Compatible Service
     * \
     * \
     * **HTTP**
     * \
     * A public HTTP URL can be used to read a video file.
     * ```json
     * {
     *     "url": "https://www.example.com/video.mp4"
     * }
     * ```
     * | Name | Type   | Description                          |
     * | ---- | ------ | ------------------------------------ |
     * | url  | string | A public HTTP URL for the video file. |
     *
     * Note: For IPFS HTTP gateway URLs, the API currently only supports “path
     * style” URLs and does not support “subdomain style” URLs. The API will
     * support both styles of URLs in a future update.
     * \
     * \
     * **S3 API Compatible Service**
     * \
     * \
     * S3 credentials can be used to authenticate with a S3 API compatible
     * service to read a video file.
     *
     * ```json
     * {
     *     "type": "s3",
     *     "endpoint": "https://gateway.storjshare.io",
     *     "credentials": {
     *         "accessKeyId": "$ACCESS_KEY_ID",
     *         "secretAccessKey": "$SECRET_ACCESS_KEY"
     *     },
     *     "bucket": "inbucket",
     *     "path": "/video/source.mp4"
     * }
     * ```
     *
     *
     * ## Storage
     * \
     * This endpoint currently supports the following storage services:
     * - S3 API Compatible Service
     * - Web3 Storage
     * \
     * \
     * **S3 API Compatible Service**
     * ```json
     * {
     *   "type": "s3",
     *     "endpoint": "https://gateway.storjshare.io",
     *     "credentials": {
     *         "accessKeyId": "$ACCESS_KEY_ID",
     *         "secretAccessKey": "$SECRET_ACCESS_KEY"
     *     },
     *     "bucket": "mybucket"
     * }
     * ```
     *
     * **Web3 Storage**
     *
     * ```json
     * {
     *   "type": "web3.storage",
     *     "credentials": {
     *         "proof": "$UCAN_DELEGATION_PROOF",
     *     }
     * }
     * ```
     *
     *
     *
     * ## Outputs
     * \
     * This endpoint currently supports the following output types:
     * - HLS
     * - MP4
     *
     * **HLS**
     *
     * ```json
     * {
     *   "hls": {
     *         "path": "/samplevideo/hls"
     *     }
     * }
     * ```
     *
     *
     * **MP4**
     *
     * ```json
     * {
     *   "mp4": {
     *         "path": "/samplevideo/mp4"
     *     }
     * }
     * ```
     *
     */
    async create(
        req: components.TranscodePayload,
        config?: AxiosRequestConfig
    ): Promise<operations.TranscodeResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new components.TranscodePayload(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/transcode";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "request", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        let globalSecurity = this.sdkConfiguration.security;
        if (typeof globalSecurity === "function") {
            globalSecurity = await globalSecurity();
        }
        if (!(globalSecurity instanceof utils.SpeakeasyBase)) {
            globalSecurity = new components.Security(globalSecurity);
        }
        const properties = utils.parseSecurityProperties(globalSecurity);
        const headers: RawAxiosRequestHeaders = {
            ...reqBodyHeaders,
            ...config?.headers,
            ...properties.headers,
        };
        if (reqBody == null) throw new Error("request body is required");
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TranscodeResponse = new operations.TranscodeResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(responseContentType, `application/json`)) {
                    res.task = utils.objectToClass(JSON.parse(decodedRes), components.Task);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + responseContentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    decodedRes,
                    httpRes
                );
        }

        return res;
    }
}
